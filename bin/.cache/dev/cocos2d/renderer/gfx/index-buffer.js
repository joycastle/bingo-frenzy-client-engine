(function () {
    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
    var __module = nodeEnv ? module : { exports: {} };
    var __filename = 'engine-dev/cocos2d/renderer/gfx/index-buffer.js';
    var __require = nodeEnv ? function (request) {
        return require(request);
    } : function (request) {
        return __quick_compile__.require(request, __filename);
    };
    function __define(exports, require, module) {
        if (!nodeEnv) {
            __quick_compile__.registerModule(__filename, module);
        }
                'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ('value' in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function (Constructor, protoProps, staticProps) {
                if (protoProps)
                    defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                    defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _BYTES_PER_INDEX;
        var _enums = require('./enums');
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function');
            }
        }
        function _defineProperty(obj, key, value) {
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value: value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
            } else {
                obj[key] = value;
            }
            return obj;
        }
        var BYTES_PER_INDEX = (_BYTES_PER_INDEX = {}, _defineProperty(_BYTES_PER_INDEX, _enums.enums.INDEX_FMT_UINT8, 1), _defineProperty(_BYTES_PER_INDEX, _enums.enums.INDEX_FMT_UINT16, 2), _defineProperty(_BYTES_PER_INDEX, _enums.enums.INDEX_FMT_UINT32, 4), _BYTES_PER_INDEX);
        var IndexBuffer = function () {
            function IndexBuffer(device, format, usage, data) {
                _classCallCheck(this, IndexBuffer);
                this._device = device;
                this._format = format;
                this._usage = usage;
                this._bytesPerIndex = BYTES_PER_INDEX[format];
                this._bytes = data.byteLength;
                this._numIndices = this._bytes / this._bytesPerIndex;
                this._needExpandDataStore = true;
                this._glID = device._gl.createBuffer();
                this.update(0, data);
                device._stats.ib += this._bytes;
            }
            _createClass(IndexBuffer, [
                {
                    key: 'destroy',
                    value: function destroy() {
                        if (this._glID === -1) {
                            console.error('The buffer already destroyed');
                            return;
                        }
                        var gl = this._device._gl;
                        gl.deleteBuffer(this._glID);
                        this._device._stats.ib -= this.bytes;
                        this._glID = -1;
                    }
                },
                {
                    key: 'update',
                    value: function update(byteOffset, data) {
                        if (this._glID === -1) {
                            console.error('The buffer is destroyed');
                            return;
                        }
                        if (data.byteLength === 0)
                            return;
                        if (byteOffset + data.byteLength > this._bytes) {
                            if (byteOffset) {
                                console.error('Failed to update data, bytes exceed.');
                                return;
                            } else {
                                this._needExpandDataStore = true;
                                this._bytes = byteOffset + data.byteLength;
                                this._numIndices = this._bytes / this._bytesPerIndex;
                            }
                        }
                        var gl = this._device._gl;
                        var glUsage = this._usage;
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._glID);
                        if (this._needExpandDataStore) {
                            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, glUsage);
                            this._needExpandDataStore = false;
                        } else {
                            gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, byteOffset, data);
                        }
                        this._device._restoreIndexBuffer();
                    }
                },
                {
                    key: 'setUsage',
                    value: function setUsage(usage) {
                        this._usage = usage;
                    }
                },
                {
                    key: 'count',
                    get: function get() {
                        return this._numIndices;
                    }
                }
            ]);
            return IndexBuffer;
        }();
        IndexBuffer.BYTES_PER_INDEX = BYTES_PER_INDEX;
        exports.default = IndexBuffer;
        module.exports = exports['default'];
    }
    if (nodeEnv) {
        __define(__module.exports, __require, __module);
    } else {
        __quick_compile__.registerModuleFunc(__filename, function () {
            __define(__module.exports, __require, __module);
        });
    }
}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImluZGV4LWJ1ZmZlci5qcyIsIi9Vc2Vycy9nYW95YW5nL1dvcmtTcGFjZS9qb3ljYXN0bGUvYmluZ28vY2xpZW50L2JpbmdvL2VuZ2luZS9jb2NvczJkL3JlbmRlcmVyL2dmeC9pbmRleC1idWZmZXIuanMiXSwibmFtZXMiOlsiQllURVNfUEVSX0lOREVYIiwiZW51bXMiLCJJTkRFWF9GTVRfVUlOVDgiLCJJTkRFWF9GTVRfVUlOVDE2IiwiSU5ERVhfRk1UX1VJTlQzMiIsIkluZGV4QnVmZmVyIiwiZGV2aWNlIiwiZm9ybWF0IiwidXNhZ2UiLCJkYXRhIiwiX2RldmljZSIsIl9mb3JtYXQiLCJfdXNhZ2UiLCJfYnl0ZXNQZXJJbmRleCIsIl9ieXRlcyIsImJ5dGVMZW5ndGgiLCJfbnVtSW5kaWNlcyIsIl9uZWVkRXhwYW5kRGF0YVN0b3JlIiwiX2dsSUQiLCJfZ2wiLCJjcmVhdGVCdWZmZXIiLCJ1cGRhdGUiLCJfc3RhdHMiLCJpYiIsImNvbnNvbGUiLCJlcnJvciIsImdsIiwiZGVsZXRlQnVmZmVyIiwiYnl0ZXMiLCJieXRlT2Zmc2V0IiwiZ2xVc2FnZSIsImJpbmRCdWZmZXIiLCJFTEVNRU5UX0FSUkFZX0JVRkZFUiIsImJ1ZmZlckRhdGEiLCJidWZmZXJTdWJEYXRhIiwiX3Jlc3RvcmVJbmRleEJ1ZmZlciJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0lBQUEsU0FBQSxRQUFBLENBQUEsT0FBQSxFQUFBLE9BQUEsRUFBQSxNQUFBLEVBQUE7QUFBQTs7U0FBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBQUEsSUFBQSxNQUFBLEdBQUEsT0FBQSxDQUFBLFNBQUEsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQUVBLElBQU1BLGVBQUFBLEdBQUFBLENBQUFBLGdCQUFBQSxHQUFBQSxFQUFBQSxFQUFBQSxlQUFBQSxDQUFBQSxnQkFBQUEsRUFDSEMsTUFBQUEsQ0FBQUEsS0FBQUEsQ0FBTUMsZUFESEYsRUFDcUIsQ0FEckJBLENBQUFBLEVBQUEsZUFBQSxD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SyxLQUFLaEIsT0FBTCxDQUFhUyxHQUF0QixDQXZCdUI7QUFBQSx3QkF3QnZCLElBQUlXLE9BQUFBLEdBQVUsS0FBS2xCLE1BQW5CLENBeEJ1QjtBQUFBLHdCQTBCdkJjLEVBQUFBLENBQUdLLFVBQUhMLENBQWNBLEVBQUFBLENBQUdNLG9CQUFqQk4sRUFBdUMsS0FBS1IsS0FBNUNRLEVBMUJ1QjtBQUFBLHdCQTJCdkIsSUFBSSxLQUFLVCxvQkFBVCxFQUErQjtBQUFBLDRCQUM3QlMsRUFBQUEsQ0FBR08sVUFBSFAsQ0FBY0EsRUFBQUEsQ0FBR00sb0JBQWpCTixFQUF1Q2pCLElBQXZDaUIsRUFBNkNJLE9BQTdDSixFQUQ2QjtBQUFBLDRCQUU3QixLQUFLVCxvQkFBTCxHQUE0QixLQUE1QixDQUY2QjtBQUFBLHlCQUEvQixNQUlLO0FBQUEsNEJBQ0hTLEVBQUFBLENBQUdRLGFBQUhSLENBQWlCQSxFQUFBQSxDQUFHTSxvQkFBcEJOLEVBQTBDRyxVQUExQ0gsRUFBc0RqQixJQUF0RGlCLEVBREc7QUFBQSx5QkEvQmtCO0FBQUEsd0JBa0N2QixLQUFLaEIsT0FBTCxDQUFheUIsbUJBQWIsR0FsQ3VCO0FBQUE7Ozs7NkNBeUNmM0IsT0FBTztBQUFBLHdCQUNmLEtBQUtJLE1BQUwsR0FBY0osS0FBZCxDQURlO0FBQUE7Ozs7d0NBSko7QUFBQSx3QkFDWCxPQUFPLEtBQUtRLFdBQVosQ0FEVztBQUFBOzs7OztRQVNmWCxXQUFBQSxDQUFZTCxlQUFaSyxHQUE4QkwsZUFBOUJLOzBCQUVlQTs0Q0F2R2Y7QUFBQTs7O1dBRU1MO0FBQUFBOztXQUFBQTtBQUFBQSIsImZpbGUiOiJpbmRleC1idWZmZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlbnVtcyB9IGZyb20gJy4vZW51bXMnO1xuXG5jb25zdCBCWVRFU19QRVJfSU5ERVggPSB7XG4gIFtlbnVtcy5JTkRFWF9GTVRfVUlOVDhdOiAxLFxuICBbZW51bXMuSU5ERVhfRk1UX1VJTlQxNl06IDIsXG4gIFtlbnVtcy5JTkRFWF9GTVRfVUlOVDMyXTogNCxcbn1cblxuY2xhc3MgSW5kZXhCdWZmZXIge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VcbiAgICogQHBhcmFtIHtJTkRFWF9GTVRfKn0gZm9ybWF0XG4gICAqIEBwYXJhbSB7VVNBR0VfKn0gdXNhZ2VcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlciB8IFVpbnQ4QXJyYXl9IGRhdGFcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRldmljZSwgZm9ybWF0LCB1c2FnZSwgZGF0YSkge1xuICAgIHRoaXMuX2RldmljZSA9IGRldmljZTtcbiAgICB0aGlzLl9mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5fdXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLl9ieXRlc1BlckluZGV4ID0gQllURVNfUEVSX0lOREVYW2Zvcm1hdF07XG4gICAgdGhpcy5fYnl0ZXMgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5fbnVtSW5kaWNlcyA9IHRoaXMuX2J5dGVzIC8gdGhpcy5fYnl0ZXNQZXJJbmRleDtcblxuICAgIHRoaXMuX25lZWRFeHBhbmREYXRhU3RvcmUgPSB0cnVlO1xuXG4gICAgLy8gdXBkYXRlXG4gICAgdGhpcy5fZ2xJRCA9IGRldmljZS5fZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy51cGRhdGUoMCwgZGF0YSk7XG5cbiAgICAvLyBzdGF0c1xuICAgIGRldmljZS5fc3RhdHMuaWIgKz0gdGhpcy5fYnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBkZXN0cm95XG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9nbElEID09PSAtMSkge1xuICAgICAgY29uc29sZS5lcnJvcignVGhlIGJ1ZmZlciBhbHJlYWR5IGRlc3Ryb3llZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBnbCA9IHRoaXMuX2RldmljZS5fZ2w7XG4gICAgZ2wuZGVsZXRlQnVmZmVyKHRoaXMuX2dsSUQpO1xuICAgIHRoaXMuX2RldmljZS5fc3RhdHMuaWIgLT0gdGhpcy5ieXRlcztcblxuICAgIHRoaXMuX2dsSUQgPSAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKiBAcGFyYW0ge051bWJlcn0gYnl0ZU9mZnNldFxuICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gICAqL1xuICB1cGRhdGUoYnl0ZU9mZnNldCwgZGF0YSkge1xuICAgIGlmICh0aGlzLl9nbElEID09PSAtMSkge1xuICAgICAgY29uc29sZS5lcnJvcignVGhlIGJ1ZmZlciBpcyBkZXN0cm95ZWQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAvLyBOZWVkIHRvIGNyZWF0ZSBuZXcgYnVmZmVyIG9iamVjdCB3aGVuIGJ5dGVzIGV4Y2VlZFxuICAgIGlmIChieXRlT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoID4gdGhpcy5fYnl0ZXMpIHtcbiAgICAgIGlmIChieXRlT2Zmc2V0KSB7XG4gICAgICAgIC8vIExvc3QgZGF0YSBiZXR3ZWVuIFswLCBieXRlT2Zmc2V0XSB3aGljaCBpcyBuZWVkIGZvciBuZXcgYnVmZmVyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgZGF0YSwgYnl0ZXMgZXhjZWVkLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmVlZEV4cGFuZERhdGFTdG9yZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2J5dGVzID0gYnl0ZU9mZnNldCArIGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgdGhpcy5fbnVtSW5kaWNlcyA9IHRoaXMuX2J5dGVzIC8gdGhpcy5fYnl0ZXNQZXJJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQHR5cGV7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSAqL1xuICAgIGxldCBnbCA9IHRoaXMuX2RldmljZS5fZ2w7XG4gICAgbGV0IGdsVXNhZ2UgPSB0aGlzLl91c2FnZTtcblxuICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuX2dsSUQpO1xuICAgIGlmICh0aGlzLl9uZWVkRXhwYW5kRGF0YVN0b3JlKSB7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBkYXRhLCBnbFVzYWdlKTtcbiAgICAgIHRoaXMuX25lZWRFeHBhbmREYXRhU3RvcmUgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBieXRlT2Zmc2V0LCBkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5fZGV2aWNlLl9yZXN0b3JlSW5kZXhCdWZmZXIoKTtcbiAgfVxuXG4gIGdldCBjb3VudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX251bUluZGljZXM7XG4gIH1cblxuICBzZXRVc2FnZSAodXNhZ2UpIHtcbiAgICB0aGlzLl91c2FnZSA9IHVzYWdlO1xuICB9XG59XG5cbkluZGV4QnVmZmVyLkJZVEVTX1BFUl9JTkRFWCA9IEJZVEVTX1BFUl9JTkRFWDtcblxuZXhwb3J0IGRlZmF1bHQgSW5kZXhCdWZmZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfQllURVNfUEVSX0lOREVYO1xuXG52YXIgX2VudW1zID0gcmVxdWlyZSgnLi9lbnVtcycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgQllURVNfUEVSX0lOREVYID0gKF9CWVRFU19QRVJfSU5ERVggPSB7fSwgX2RlZmluZVByb3BlcnR5KF9CWVRFU19QRVJfSU5ERVgsIF9lbnVtcy5lbnVtcy5JTkRFWF9GTVRfVUlOVDgsIDEpLCBfZGVmaW5lUHJvcGVydHkoX0JZVEVTX1BFUl9JTkRFWCwgX2VudW1zLmVudW1zLklOREVYX0ZNVF9VSU5UMTYsIDIpLCBfZGVmaW5lUHJvcGVydHkoX0JZVEVTX1BFUl9JTkRFWCwgX2VudW1zLmVudW1zLklOREVYX0ZNVF9VSU5UMzIsIDQpLCBfQllURVNfUEVSX0lOREVYKTtcblxudmFyIEluZGV4QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VcbiAgICogQHBhcmFtIHtJTkRFWF9GTVRfKn0gZm9ybWF0XG4gICAqIEBwYXJhbSB7VVNBR0VfKn0gdXNhZ2VcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlciB8IFVpbnQ4QXJyYXl9IGRhdGFcbiAgICovXG4gIGZ1bmN0aW9uIEluZGV4QnVmZmVyKGRldmljZSwgZm9ybWF0LCB1c2FnZSwgZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmRleEJ1ZmZlcik7XG5cbiAgICB0aGlzLl9kZXZpY2UgPSBkZXZpY2U7XG4gICAgdGhpcy5fZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMuX3VzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy5fYnl0ZXNQZXJJbmRleCA9IEJZVEVTX1BFUl9JTkRFWFtmb3JtYXRdO1xuICAgIHRoaXMuX2J5dGVzID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMuX251bUluZGljZXMgPSB0aGlzLl9ieXRlcyAvIHRoaXMuX2J5dGVzUGVySW5kZXg7XG5cbiAgICB0aGlzLl9uZWVkRXhwYW5kRGF0YVN0b3JlID0gdHJ1ZTtcblxuICAgIC8vIHVwZGF0ZVxuICAgIHRoaXMuX2dsSUQgPSBkZXZpY2UuX2dsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIHRoaXMudXBkYXRlKDAsIGRhdGEpO1xuXG4gICAgLy8gc3RhdHNcbiAgICBkZXZpY2UuX3N0YXRzLmliICs9IHRoaXMuX2J5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgZGVzdHJveVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhJbmRleEJ1ZmZlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLl9nbElEID09PSAtMSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgYnVmZmVyIGFscmVhZHkgZGVzdHJveWVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdsID0gdGhpcy5fZGV2aWNlLl9nbDtcbiAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl9nbElEKTtcbiAgICAgIHRoaXMuX2RldmljZS5fc3RhdHMuaWIgLT0gdGhpcy5ieXRlcztcblxuICAgICAgdGhpcy5fZ2xJRCA9IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVPZmZzZXRcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShieXRlT2Zmc2V0LCBkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fZ2xJRCA9PT0gLTEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVGhlIGJ1ZmZlciBpcyBkZXN0cm95ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIC8vIE5lZWQgdG8gY3JlYXRlIG5ldyBidWZmZXIgb2JqZWN0IHdoZW4gYnl0ZXMgZXhjZWVkXG4gICAgICBpZiAoYnl0ZU9mZnNldCArIGRhdGEuYnl0ZUxlbmd0aCA+IHRoaXMuX2J5dGVzKSB7XG4gICAgICAgIGlmIChieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgLy8gTG9zdCBkYXRhIGJldHdlZW4gWzAsIGJ5dGVPZmZzZXRdIHdoaWNoIGlzIG5lZWQgZm9yIG5ldyBidWZmZXJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGRhdGEsIGJ5dGVzIGV4Y2VlZC4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbmVlZEV4cGFuZERhdGFTdG9yZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fYnl0ZXMgPSBieXRlT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHRoaXMuX251bUluZGljZXMgPSB0aGlzLl9ieXRlcyAvIHRoaXMuX2J5dGVzUGVySW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqIEB0eXBle1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gKi9cbiAgICAgIHZhciBnbCA9IHRoaXMuX2RldmljZS5fZ2w7XG4gICAgICB2YXIgZ2xVc2FnZSA9IHRoaXMuX3VzYWdlO1xuXG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCB0aGlzLl9nbElEKTtcbiAgICAgIGlmICh0aGlzLl9uZWVkRXhwYW5kRGF0YVN0b3JlKSB7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGRhdGEsIGdsVXNhZ2UpO1xuICAgICAgICB0aGlzLl9uZWVkRXhwYW5kRGF0YVN0b3JlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBieXRlT2Zmc2V0LCBkYXRhKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RldmljZS5fcmVzdG9yZUluZGV4QnVmZmVyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0VXNhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVc2FnZSh1c2FnZSkge1xuICAgICAgdGhpcy5fdXNhZ2UgPSB1c2FnZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb3VudCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbnVtSW5kaWNlcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSW5kZXhCdWZmZXI7XG59KCk7XG5cbkluZGV4QnVmZmVyLkJZVEVTX1BFUl9JTkRFWCA9IEJZVEVTX1BFUl9JTkRFWDtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSW5kZXhCdWZmZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkltbHVaR1Y0TFdKMVptWmxjaTVxY3lKZExDSnVZVzFsY3lJNld5SkNXVlJGVTE5UVJWSmZTVTVFUlZnaUxDSmxiblZ0Y3lJc0lrbE9SRVZZWDBaTlZGOVZTVTVVT0NJc0lrbE9SRVZZWDBaTlZGOVZTVTVVTVRZaUxDSkpUa1JGV0Y5R1RWUmZWVWxPVkRNeUlpd2lTVzVrWlhoQ2RXWm1aWElpTENKa1pYWnBZMlVpTENKbWIzSnRZWFFpTENKMWMyRm5aU0lzSW1SaGRHRWlMQ0pmWkdWMmFXTmxJaXdpWDJadmNtMWhkQ0lzSWw5MWMyRm5aU0lzSWw5aWVYUmxjMUJsY2tsdVpHVjRJaXdpWDJKNWRHVnpJaXdpWW5sMFpVeGxibWQwYUNJc0lsOXVkVzFKYm1ScFkyVnpJaXdpWDI1bFpXUkZlSEJoYm1SRVlYUmhVM1J2Y21VaUxDSmZaMnhKUkNJc0lsOW5iQ0lzSW1OeVpXRjBaVUoxWm1abGNpSXNJblZ3WkdGMFpTSXNJbDl6ZEdGMGN5SXNJbWxpSWl3aVkyOXVjMjlzWlNJc0ltVnljbTl5SWl3aVoyd2lMQ0prWld4bGRHVkNkV1ptWlhJaUxDSmllWFJsY3lJc0ltSjVkR1ZQWm1aelpYUWlMQ0puYkZWellXZGxJaXdpWW1sdVpFSjFabVpsY2lJc0lrVk1SVTFGVGxSZlFWSlNRVmxmUWxWR1JrVlNJaXdpWW5WbVptVnlSR0YwWVNJc0ltSjFabVpsY2xOMVlrUmhkR0VpTENKZmNtVnpkRzl5WlVsdVpHVjRRblZtWm1WeUlsMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3TzBGQlFVRTdPenM3T3p0QlFVVkJMRWxCUVUxQkxEUkZRVU5JUXl4aFFVRk5ReXhsUVVSSUxFVkJRM0ZDTEVOQlJISkNMSEZEUVVWSVJDeGhRVUZOUlN4blFrRkdTQ3hGUVVWelFpeERRVVowUWl4eFEwRkhTRVlzWVVGQlRVY3NaMEpCU0Vnc1JVRkhjMElzUTBGSWRFSXNiMEpCUVU0N08wbEJUVTFETEZjN1FVRkRTanM3T3pzN096dEJRVTlCTEhWQ1FVRlpReXhOUVVGYUxFVkJRVzlDUXl4TlFVRndRaXhGUVVFMFFrTXNTMEZCTlVJc1JVRkJiVU5ETEVsQlFXNURMRVZCUVhsRE8wRkJRVUU3TzBGQlEzWkRMRk5CUVV0RExFOUJRVXdzUjBGQlpVb3NUVUZCWmp0QlFVTkJMRk5CUVV0TExFOUJRVXdzUjBGQlpVb3NUVUZCWmp0QlFVTkJMRk5CUVV0TExFMUJRVXdzUjBGQlkwb3NTMEZCWkR0QlFVTkJMRk5CUVV0TExHTkJRVXdzUjBGQmMwSmlMR2RDUVVGblFrOHNUVUZCYUVJc1EwRkJkRUk3UVVGRFFTeFRRVUZMVHl4TlFVRk1MRWRCUVdOTUxFdEJRVXROTEZWQlFXNUNPMEZCUTBFc1UwRkJTME1zVjBGQlRDeEhRVUZ0UWl4TFFVRkxSaXhOUVVGTUxFZEJRV01zUzBGQlMwUXNZMEZCZEVNN08wRkJSVUVzVTBGQlMwa3NiMEpCUVV3c1IwRkJORUlzU1VGQk5VSTdPMEZCUlVFN1FVRkRRU3hUUVVGTFF5eExRVUZNTEVkQlFXRmFMRTlCUVU5aExFZEJRVkFzUTBGQlYwTXNXVUZCV0N4RlFVRmlPMEZCUTBFc1UwRkJTME1zVFVGQlRDeERRVUZaTEVOQlFWb3NSVUZCWlZvc1NVRkJaanM3UVVGRlFUdEJRVU5CU0N4WFFVRlBaMElzVFVGQlVDeERRVUZqUXl4RlFVRmtMRWxCUVc5Q0xFdEJRVXRVTEUxQlFYcENPMEZCUTBRN08wRkJSVVE3T3pzN096czdPRUpCUjFVN1FVRkRVaXhWUVVGSkxFdEJRVXRKTEV0QlFVd3NTMEZCWlN4RFFVRkRMRU5CUVhCQ0xFVkJRWFZDTzBGQlEzSkNUU3huUWtGQlVVTXNTMEZCVWl4RFFVRmpMRGhDUVVGa08wRkJRMEU3UVVGRFJEczdRVUZGUkN4VlFVRkpReXhMUVVGTExFdEJRVXRvUWl4UFFVRk1MRU5CUVdGVExFZEJRWFJDTzBGQlEwRlBMRk5CUVVkRExGbEJRVWdzUTBGQlowSXNTMEZCUzFRc1MwRkJja0k3UVVGRFFTeFhRVUZMVWl4UFFVRk1MRU5CUVdGWkxFMUJRV0lzUTBGQmIwSkRMRVZCUVhCQ0xFbEJRVEJDTEV0QlFVdExMRXRCUVM5Q096dEJRVVZCTEZkQlFVdFdMRXRCUVV3c1IwRkJZU3hEUVVGRExFTkJRV1E3UVVGRFJEczdRVUZGUkRzN096czdPenM3TWtKQlMwOVhMRlVzUlVGQldYQkNMRWtzUlVGQlRUdEJRVU4yUWl4VlFVRkpMRXRCUVV0VExFdEJRVXdzUzBGQlpTeERRVUZETEVOQlFYQkNMRVZCUVhWQ08wRkJRM0pDVFN4blFrRkJVVU1zUzBGQlVpeERRVUZqTEhsQ1FVRmtPMEZCUTBFN1FVRkRSRHM3UVVGRlJDeFZRVUZKYUVJc1MwRkJTMDBzVlVGQlRDeExRVUZ2UWl4RFFVRjRRaXhGUVVFeVFqczdRVUZGTTBJN1FVRkRRU3hWUVVGSll5eGhRVUZoY0VJc1MwRkJTMDBzVlVGQmJFSXNSMEZCSzBJc1MwRkJTMFFzVFVGQmVFTXNSVUZCWjBRN1FVRkRPVU1zV1VGQlNXVXNWVUZCU2l4RlFVRm5RanRCUVVOa08wRkJRMEZNTEd0Q1FVRlJReXhMUVVGU0xFTkJRV01zYzBOQlFXUTdRVUZEUVR0QlFVTkVMRk5CU2tRc1RVRkxTenRCUVVOSUxHVkJRVXRTTEc5Q1FVRk1MRWRCUVRSQ0xFbEJRVFZDTzBGQlEwRXNaVUZCUzBnc1RVRkJUQ3hIUVVGalpTeGhRVUZoY0VJc1MwRkJTMDBzVlVGQmFFTTdRVUZEUVN4bFFVRkxReXhYUVVGTUxFZEJRVzFDTEV0QlFVdEdMRTFCUVV3c1IwRkJZeXhMUVVGTFJDeGpRVUYwUXp0QlFVTkVPMEZCUTBZN08wRkJSVVE3UVVGRFFTeFZRVUZKWVN4TFFVRkxMRXRCUVV0b1FpeFBRVUZNTEVOQlFXRlRMRWRCUVhSQ08wRkJRMEVzVlVGQlNWY3NWVUZCVlN4TFFVRkxiRUlzVFVGQmJrSTdPMEZCUlVGakxGTkJRVWRMTEZWQlFVZ3NRMEZCWTB3c1IwRkJSMDBzYjBKQlFXcENMRVZCUVhWRExFdEJRVXRrTEV0QlFUVkRPMEZCUTBFc1ZVRkJTU3hMUVVGTFJDeHZRa0ZCVkN4RlFVRXJRanRCUVVNM1FsTXNWMEZCUjA4c1ZVRkJTQ3hEUVVGalVDeEhRVUZIVFN4dlFrRkJha0lzUlVGQmRVTjJRaXhKUVVGMlF5eEZRVUUyUTNGQ0xFOUJRVGRETzBGQlEwRXNZVUZCUzJJc2IwSkJRVXdzUjBGQk5FSXNTMEZCTlVJN1FVRkRSQ3hQUVVoRUxFMUJTVXM3UVVGRFNGTXNWMEZCUjFFc1lVRkJTQ3hEUVVGcFFsSXNSMEZCUjAwc2IwSkJRWEJDTEVWQlFUQkRTQ3hWUVVFeFF5eEZRVUZ6UkhCQ0xFbEJRWFJFTzBGQlEwUTdRVUZEUkN4WFFVRkxReXhQUVVGTUxFTkJRV0Y1UWl4dFFrRkJZanRCUVVORU96czdOa0pCVFZNelFpeExMRVZCUVU4N1FVRkRaaXhYUVVGTFNTeE5RVUZNTEVkQlFXTktMRXRCUVdRN1FVRkRSRHM3TzNkQ1FVNVpPMEZCUTFnc1lVRkJUeXhMUVVGTFVTeFhRVUZhTzBGQlEwUTdPenM3T3p0QlFVOUlXQ3haUVVGWlRDeGxRVUZhTEVkQlFUaENRU3hsUVVFNVFqczdhMEpCUldWTExGY2lMQ0ptYVd4bElqb2lhVzVrWlhndFluVm1abVZ5TG1weklpd2ljMjkxY21ObGMwTnZiblJsYm5RaU9sc2lhVzF3YjNKMElIc2daVzUxYlhNZ2ZTQm1jbTl0SUNjdUwyVnVkVzF6Snp0Y2JseHVZMjl1YzNRZ1FsbFVSVk5mVUVWU1gwbE9SRVZZSUQwZ2UxeHVJQ0JiWlc1MWJYTXVTVTVFUlZoZlJrMVVYMVZKVGxRNFhUb2dNU3hjYmlBZ1cyVnVkVzF6TGtsT1JFVllYMFpOVkY5VlNVNVVNVFpkT2lBeUxGeHVJQ0JiWlc1MWJYTXVTVTVFUlZoZlJrMVVYMVZKVGxRek1sMDZJRFFzWEc1OVhHNWNibU5zWVhOeklFbHVaR1Y0UW5WbVptVnlJSHRjYmlBZ0x5b3FYRzRnSUNBcUlFQmpiMjV6ZEhKMVkzUnZjbHh1SUNBZ0tpQkFjR0Z5WVcwZ2UwUmxkbWxqWlgwZ1pHVjJhV05sWEc0Z0lDQXFJRUJ3WVhKaGJTQjdTVTVFUlZoZlJrMVVYeXA5SUdadmNtMWhkRnh1SUNBZ0tpQkFjR0Z5WVcwZ2UxVlRRVWRGWHlwOUlIVnpZV2RsWEc0Z0lDQXFJRUJ3WVhKaGJTQjdRWEp5WVhsQ2RXWm1aWElnZkNCVmFXNTBPRUZ5Y21GNWZTQmtZWFJoWEc0Z0lDQXFMMXh1SUNCamIyNXpkSEoxWTNSdmNpaGtaWFpwWTJVc0lHWnZjbTFoZEN3Z2RYTmhaMlVzSUdSaGRHRXBJSHRjYmlBZ0lDQjBhR2x6TGw5a1pYWnBZMlVnUFNCa1pYWnBZMlU3WEc0Z0lDQWdkR2hwY3k1ZlptOXliV0YwSUQwZ1ptOXliV0YwTzF4dUlDQWdJSFJvYVhNdVgzVnpZV2RsSUQwZ2RYTmhaMlU3WEc0Z0lDQWdkR2hwY3k1ZllubDBaWE5RWlhKSmJtUmxlQ0E5SUVKWlZFVlRYMUJGVWw5SlRrUkZXRnRtYjNKdFlYUmRPMXh1SUNBZ0lIUm9hWE11WDJKNWRHVnpJRDBnWkdGMFlTNWllWFJsVEdWdVozUm9PMXh1SUNBZ0lIUm9hWE11WDI1MWJVbHVaR2xqWlhNZ1BTQjBhR2x6TGw5aWVYUmxjeUF2SUhSb2FYTXVYMko1ZEdWelVHVnlTVzVrWlhnN1hHNWNiaUFnSUNCMGFHbHpMbDl1WldWa1JYaHdZVzVrUkdGMFlWTjBiM0psSUQwZ2RISjFaVHRjYmx4dUlDQWdJQzh2SUhWd1pHRjBaVnh1SUNBZ0lIUm9hWE11WDJkc1NVUWdQU0JrWlhacFkyVXVYMmRzTG1OeVpXRjBaVUoxWm1abGNpZ3BPMXh1SUNBZ0lIUm9hWE11ZFhCa1lYUmxLREFzSUdSaGRHRXBPMXh1WEc0Z0lDQWdMeThnYzNSaGRITmNiaUFnSUNCa1pYWnBZMlV1WDNOMFlYUnpMbWxpSUNzOUlIUm9hWE11WDJKNWRHVnpPMXh1SUNCOVhHNWNiaUFnTHlvcVhHNGdJQ0FxSUVCdFpYUm9iMlFnWkdWemRISnZlVnh1SUNBZ0tpOWNiaUFnWkdWemRISnZlU2dwSUh0Y2JpQWdJQ0JwWmlBb2RHaHBjeTVmWjJ4SlJDQTlQVDBnTFRFcElIdGNiaUFnSUNBZ0lHTnZibk52YkdVdVpYSnliM0lvSjFSb1pTQmlkV1ptWlhJZ1lXeHlaV0ZrZVNCa1pYTjBjbTk1WldRbktUdGNiaUFnSUNBZ0lISmxkSFZ5Ymp0Y2JpQWdJQ0I5WEc1Y2JpQWdJQ0JzWlhRZ1oyd2dQU0IwYUdsekxsOWtaWFpwWTJVdVgyZHNPMXh1SUNBZ0lHZHNMbVJsYkdWMFpVSjFabVpsY2loMGFHbHpMbDluYkVsRUtUdGNiaUFnSUNCMGFHbHpMbDlrWlhacFkyVXVYM04wWVhSekxtbGlJQzA5SUhSb2FYTXVZbmwwWlhNN1hHNWNiaUFnSUNCMGFHbHpMbDluYkVsRUlEMGdMVEU3WEc0Z0lIMWNibHh1SUNBdktpcGNiaUFnSUNvZ1FHMWxkR2h2WkNCMWNHUmhkR1ZjYmlBZ0lDb2dRSEJoY21GdElIdE9kVzFpWlhKOUlHSjVkR1ZQWm1aelpYUmNiaUFnSUNvZ1FIQmhjbUZ0SUh0QmNuSmhlVUoxWm1abGNuMGdaR0YwWVZ4dUlDQWdLaTljYmlBZ2RYQmtZWFJsS0dKNWRHVlBabVp6WlhRc0lHUmhkR0VwSUh0Y2JpQWdJQ0JwWmlBb2RHaHBjeTVmWjJ4SlJDQTlQVDBnTFRFcElIdGNiaUFnSUNBZ0lHTnZibk52YkdVdVpYSnliM0lvSjFSb1pTQmlkV1ptWlhJZ2FYTWdaR1Z6ZEhKdmVXVmtKeWs3WEc0Z0lDQWdJQ0J5WlhSMWNtNDdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2FXWWdLR1JoZEdFdVlubDBaVXhsYm1kMGFDQTlQVDBnTUNrZ2NtVjBkWEp1TzF4dVhHNGdJQ0FnTHk4Z1RtVmxaQ0IwYnlCamNtVmhkR1VnYm1WM0lHSjFabVpsY2lCdlltcGxZM1FnZDJobGJpQmllWFJsY3lCbGVHTmxaV1JjYmlBZ0lDQnBaaUFvWW5sMFpVOW1abk5sZENBcklHUmhkR0V1WW5sMFpVeGxibWQwYUNBK0lIUm9hWE11WDJKNWRHVnpLU0I3WEc0Z0lDQWdJQ0JwWmlBb1lubDBaVTltWm5ObGRDa2dlMXh1SUNBZ0lDQWdJQ0F2THlCTWIzTjBJR1JoZEdFZ1ltVjBkMlZsYmlCYk1Dd2dZbmwwWlU5bVpuTmxkRjBnZDJocFkyZ2dhWE1nYm1WbFpDQm1iM0lnYm1WM0lHSjFabVpsY2x4dUlDQWdJQ0FnSUNCamIyNXpiMnhsTG1WeWNtOXlLQ2RHWVdsc1pXUWdkRzhnZFhCa1lYUmxJR1JoZEdFc0lHSjVkR1Z6SUdWNFkyVmxaQzRuS1R0Y2JpQWdJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJQ0FnZlZ4dUlDQWdJQ0FnWld4elpTQjdYRzRnSUNBZ0lDQWdJSFJvYVhNdVgyNWxaV1JGZUhCaGJtUkVZWFJoVTNSdmNtVWdQU0IwY25WbE8xeHVJQ0FnSUNBZ0lDQjBhR2x6TGw5aWVYUmxjeUE5SUdKNWRHVlBabVp6WlhRZ0t5QmtZWFJoTG1KNWRHVk1aVzVuZEdnN1hHNGdJQ0FnSUNBZ0lIUm9hWE11WDI1MWJVbHVaR2xqWlhNZ1BTQjBhR2x6TGw5aWVYUmxjeUF2SUhSb2FYTXVYMko1ZEdWelVHVnlTVzVrWlhnN1hHNGdJQ0FnSUNCOVhHNGdJQ0FnZlZ4dVhHNGdJQ0FnTHlvcUlFQjBlWEJsZTFkbFlrZE1VbVZ1WkdWeWFXNW5RMjl1ZEdWNGRIMGdLaTljYmlBZ0lDQnNaWFFnWjJ3Z1BTQjBhR2x6TGw5a1pYWnBZMlV1WDJkc08xeHVJQ0FnSUd4bGRDQm5iRlZ6WVdkbElEMGdkR2hwY3k1ZmRYTmhaMlU3WEc1Y2JpQWdJQ0JuYkM1aWFXNWtRblZtWm1WeUtHZHNMa1ZNUlUxRlRsUmZRVkpTUVZsZlFsVkdSa1ZTTENCMGFHbHpMbDluYkVsRUtUdGNiaUFnSUNCcFppQW9kR2hwY3k1ZmJtVmxaRVY0Y0dGdVpFUmhkR0ZUZEc5eVpTa2dlMXh1SUNBZ0lDQWdaMnd1WW5WbVptVnlSR0YwWVNobmJDNUZURVZOUlU1VVgwRlNVa0ZaWDBKVlJrWkZVaXdnWkdGMFlTd2daMnhWYzJGblpTazdYRzRnSUNBZ0lDQjBhR2x6TGw5dVpXVmtSWGh3WVc1a1JHRjBZVk4wYjNKbElEMGdabUZzYzJVN1hHNGdJQ0FnZlZ4dUlDQWdJR1ZzYzJVZ2UxeHVJQ0FnSUNBZ1oyd3VZblZtWm1WeVUzVmlSR0YwWVNobmJDNUZURVZOUlU1VVgwRlNVa0ZaWDBKVlJrWkZVaXdnWW5sMFpVOW1abk5sZEN3Z1pHRjBZU2s3WEc0Z0lDQWdmVnh1SUNBZ0lIUm9hWE11WDJSbGRtbGpaUzVmY21WemRHOXlaVWx1WkdWNFFuVm1abVZ5S0NrN1hHNGdJSDFjYmx4dUlDQm5aWFFnWTI5MWJuUWdLQ2tnZTF4dUlDQWdJSEpsZEhWeWJpQjBhR2x6TGw5dWRXMUpibVJwWTJWek8xeHVJQ0I5WEc1Y2JpQWdjMlYwVlhOaFoyVWdLSFZ6WVdkbEtTQjdYRzRnSUNBZ2RHaHBjeTVmZFhOaFoyVWdQU0IxYzJGblpUdGNiaUFnZlZ4dWZWeHVYRzVKYm1SbGVFSjFabVpsY2k1Q1dWUkZVMTlRUlZKZlNVNUVSVmdnUFNCQ1dWUkZVMTlRUlZKZlNVNUVSVmc3WEc1Y2JtVjRjRzl5ZENCa1pXWmhkV3gwSUVsdVpHVjRRblZtWm1WeU8xeHVJbDE5Il19