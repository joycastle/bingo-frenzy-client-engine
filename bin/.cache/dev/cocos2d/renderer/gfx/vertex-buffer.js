(function () {
    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
    var __module = nodeEnv ? module : { exports: {} };
    var __filename = 'engine-dev/cocos2d/renderer/gfx/vertex-buffer.js';
    var __require = nodeEnv ? function (request) {
        return require(request);
    } : function (request) {
        return __quick_compile__.require(request, __filename);
    };
    function __define(exports, require, module) {
        if (!nodeEnv) {
            __quick_compile__.registerModule(__filename, module);
        }
                'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        var _createClass = function () {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ('value' in descriptor)
                        descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function (Constructor, protoProps, staticProps) {
                if (protoProps)
                    defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                    defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();
        var _enums = require('./enums');
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function');
            }
        }
        var VertexBuffer = function () {
            function VertexBuffer(device, format, usage, data) {
                _classCallCheck(this, VertexBuffer);
                this._device = device;
                this._format = format;
                this._usage = usage;
                this._bytesPerVertex = this._format._bytes;
                this._bytes = data.byteLength;
                this._numVertices = this._bytes / this._bytesPerVertex;
                this._needExpandDataStore = true;
                this._glID = device._gl.createBuffer();
                this.update(0, data);
                device._stats.vb += this._bytes;
            }
            _createClass(VertexBuffer, [
                {
                    key: 'destroy',
                    value: function destroy() {
                        if (this._glID === -1) {
                            console.error('The buffer already destroyed');
                            return;
                        }
                        var gl = this._device._gl;
                        gl.deleteBuffer(this._glID);
                        this._device._stats.vb -= this.bytes;
                        this._glID = -1;
                    }
                },
                {
                    key: 'update',
                    value: function update(byteOffset, data) {
                        if (this._glID === -1) {
                            console.error('The buffer is destroyed');
                            return;
                        }
                        if (data.byteLength === 0)
                            return;
                        if (byteOffset + data.byteLength > this._bytes) {
                            if (byteOffset) {
                                console.error('Failed to update data, bytes exceed.');
                                return;
                            } else {
                                this._needExpandDataStore = true;
                                this._bytes = byteOffset + data.byteLength;
                                this._numVertices = this._bytes / this._bytesPerVertex;
                            }
                        }
                        var gl = this._device._gl;
                        var glUsage = this._usage;
                        gl.bindBuffer(gl.ARRAY_BUFFER, this._glID);
                        if (this._needExpandDataStore) {
                            gl.bufferData(gl.ARRAY_BUFFER, data, glUsage);
                            this._needExpandDataStore = false;
                        } else {
                            gl.bufferSubData(gl.ARRAY_BUFFER, byteOffset, data);
                        }
                        gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    }
                },
                {
                    key: 'getFormat',
                    value: function getFormat(name) {
                        return this._format.element(name);
                    }
                },
                {
                    key: 'setUsage',
                    value: function setUsage(usage) {
                        this._usage = usage;
                    }
                },
                {
                    key: 'count',
                    get: function get() {
                        return this._numVertices;
                    }
                }
            ]);
            return VertexBuffer;
        }();
        exports.default = VertexBuffer;
        module.exports = exports['default'];
    }
    if (nodeEnv) {
        __define(__module.exports, __require, __module);
    } else {
        __quick_compile__.registerModuleFunc(__filename, function () {
            __define(__module.exports, __require, __module);
        });
    }
}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInZlcnRleC1idWZmZXIuanMiLCIvVXNlcnMvU2hhcmVkL2JpbmdvX2ZyZW56eS9lbmdpbmUvY29jb3MyZC9yZW5kZXJlci9nZngvdmVydGV4LWJ1ZmZlci5qcyJdLCJuYW1lcyI6WyJWZXJ0ZXhCdWZmZXIiLCJkZXZpY2UiLCJmb3JtYXQiLCJ1c2FnZSIsImRhdGEiLCJfZGV2aWNlIiwiX2Zvcm1hdCIsIl91c2FnZSIsIl9ieXRlc1BlclZlcnRleCIsIl9ieXRlcyIsImJ5dGVMZW5ndGgiLCJfbnVtVmVydGljZXMiLCJfbmVlZEV4cGFuZERhdGFTdG9yZSIsIl9nbElEIiwiX2dsIiwiY3JlYXRlQnVmZmVyIiwidXBkYXRlIiwiX3N0YXRzIiwidmIiLCJjb25zb2xlIiwiZXJyb3IiLCJnbCIsImRlbGV0ZUJ1ZmZlciIsImJ5dGVzIiwiYnl0ZU9mZnNldCIsImdsVXNhZ2UiLCJiaW5kQnVmZmVyIiwiQVJSQVlfQlVGRkVSIiwiYnVmZmVyRGF0YSIsImJ1ZmZlclN1YkRhdGEiLCJuYW1lIiwiZWxlbWVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztRQUFBLE9BQUEsaUJBQUEsQ0FBQSxPQUFBLENBQUEsT0FBQSxFQUFBLFVBQUEsQ0FBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBQUEsSUFBQSxNQUFBLEdBQUEsT0FBQSxDQUFBLFNBQUEsQ0FBQTs7Ozs7O1lBRU1BLFlBQUFBO1lBUUosU0FBQSxZQUFBLENBQVlDLE1BQVosRUFBb0JDLE1BQXBCLEVBQTRCQyxLQUE1QixFQUFtQ0MsSUFBbkMsRUFBeUM7QUFBQSxnQkFBQSxlQUFBLENBQUEsSUFBQSxFQUFBLFlBQUEsRUFBQTtBQUFBLGdCQUN2QyxLQUFLQyxPQUFMLEdBQWVKLE1BQWYsQ0FEdUM7QUFBQSxnQkFFdkMsS0FBS0ssT0FBTCxHQUFlSixNQUFmLENBRnVDO0FBQUEsZ0JBR3ZDLEtBQUtLLE1BQUwsR0FBY0osS0FBZCxDQUh1QztBQUFBLGdCQUl2QyxLQUFLSyxlQUFMLEdBQXVCLEtBQUtGLE9B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REc7QUFBQSx5QkE5QmtCO0FBQUEsd0JBaUN2QkEsRUFBQUEsQ0FBR0ssVUFBSEwsQ0FBY0EsRUFBQUEsQ0FBR00sWUFBakJOLEVBQStCLElBQS9CQSxFQWpDdUI7QUFBQTs7Ozs4Q0F3Q2RTLE1BQU07QUFBQSx3QkFDZixPQUFPLEtBQUt4QixPQUFMLENBQWF5QixPQUFiLENBQXFCRCxJQUFyQixDQUFQLENBRGU7QUFBQTs7Ozs2Q0FJUDNCLE9BQU87QUFBQSx3QkFDZixLQUFLSSxNQUFMLEdBQWNKLEtBQWQsQ0FEZTtBQUFBOzs7O3dDQVJKO0FBQUEsd0JBQ1gsT0FBTyxLQUFLUSxZQUFaLENBRFc7QUFBQTs7Ozs7MEJBYUFYOzs7SUEvRmIsSUFBQSxPQUFBLEVBQUE7QUFBQSx3REFBQTtBQUFBLEtBQUEiLCJmaWxlIjoidmVydGV4LWJ1ZmZlci5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGVudW1zIH0gZnJvbSAnLi9lbnVtcyc7XG5cbmNsYXNzIFZlcnRleEJ1ZmZlciB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtEZXZpY2V9IGRldmljZVxuICAgKiBAcGFyYW0ge1ZlcnRleEZvcm1hdH0gZm9ybWF0XG4gICAqIEBwYXJhbSB7VVNBR0VfKn0gdXNhZ2VcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlciB8IFVpbnQ4QXJyYXl9IGRhdGFcbiAgICovXG4gIGNvbnN0cnVjdG9yKGRldmljZSwgZm9ybWF0LCB1c2FnZSwgZGF0YSkge1xuICAgIHRoaXMuX2RldmljZSA9IGRldmljZTtcbiAgICB0aGlzLl9mb3JtYXQgPSBmb3JtYXQ7XG4gICAgdGhpcy5fdXNhZ2UgPSB1c2FnZTtcbiAgICB0aGlzLl9ieXRlc1BlclZlcnRleCA9IHRoaXMuX2Zvcm1hdC5fYnl0ZXM7XG4gICAgdGhpcy5fYnl0ZXMgPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgdGhpcy5fbnVtVmVydGljZXMgPSB0aGlzLl9ieXRlcyAvIHRoaXMuX2J5dGVzUGVyVmVydGV4O1xuXG4gICAgdGhpcy5fbmVlZEV4cGFuZERhdGFTdG9yZSA9IHRydWU7XG5cbiAgICAvLyB1cGRhdGVcbiAgICB0aGlzLl9nbElEID0gZGV2aWNlLl9nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICB0aGlzLnVwZGF0ZSgwLCBkYXRhKTtcblxuICAgIC8vIHN0YXRzXG4gICAgZGV2aWNlLl9zdGF0cy52YiArPSB0aGlzLl9ieXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX2dsSUQgPT09IC0xKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUaGUgYnVmZmVyIGFscmVhZHkgZGVzdHJveWVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGdsID0gdGhpcy5fZGV2aWNlLl9nbDtcbiAgICBnbC5kZWxldGVCdWZmZXIodGhpcy5fZ2xJRCk7XG4gICAgdGhpcy5fZGV2aWNlLl9zdGF0cy52YiAtPSB0aGlzLmJ5dGVzO1xuXG4gICAgdGhpcy5fZ2xJRCA9IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgdXBkYXRlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBieXRlT2Zmc2V0XG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAgICovXG4gIHVwZGF0ZShieXRlT2Zmc2V0LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuX2dsSUQgPT09IC0xKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUaGUgYnVmZmVyIGlzIGRlc3Ryb3llZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIC8vIE5lZWQgdG8gY3JlYXRlIG5ldyBidWZmZXIgb2JqZWN0IHdoZW4gYnl0ZXMgZXhjZWVkXG4gICAgaWYgKGJ5dGVPZmZzZXQgKyBkYXRhLmJ5dGVMZW5ndGggPiB0aGlzLl9ieXRlcykge1xuICAgICAgaWYgKGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgLy8gTG9zdCBkYXRhIGJldHdlZW4gWzAsIGJ5dGVPZmZzZXRdIHdoaWNoIGlzIG5lZWQgZm9yIG5ldyBidWZmZXJcbiAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHVwZGF0ZSBkYXRhLCBieXRlcyBleGNlZWQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl9uZWVkRXhwYW5kRGF0YVN0b3JlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fYnl0ZXMgPSBieXRlT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICB0aGlzLl9udW1WZXJ0aWNlcyA9IHRoaXMuX2J5dGVzIC8gdGhpcy5fYnl0ZXNQZXJWZXJ0ZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGdsID0gdGhpcy5fZGV2aWNlLl9nbDtcbiAgICBsZXQgZ2xVc2FnZSA9IHRoaXMuX3VzYWdlO1xuXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX2dsSUQpO1xuICAgIGlmICh0aGlzLl9uZWVkRXhwYW5kRGF0YVN0b3JlKSB7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgZGF0YSwgZ2xVc2FnZSk7XG4gICAgICB0aGlzLl9uZWVkRXhwYW5kRGF0YVN0b3JlID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIGJ5dGVPZmZzZXQsIGRhdGEpO1xuICAgIH1cbiAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gIH1cblxuICBnZXQgY291bnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9udW1WZXJ0aWNlcztcbiAgfVxuXG4gIGdldEZvcm1hdCAobmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9mb3JtYXQuZWxlbWVudChuYW1lKTtcbiAgfVxuXG4gIHNldFVzYWdlICh1c2FnZSkge1xuICAgIHRoaXMuX3VzYWdlID0gdXNhZ2U7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgVmVydGV4QnVmZmVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2VudW1zID0gcmVxdWlyZSgnLi9lbnVtcycpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVmVydGV4QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7RGV2aWNlfSBkZXZpY2VcbiAgICogQHBhcmFtIHtWZXJ0ZXhGb3JtYXR9IGZvcm1hdFxuICAgKiBAcGFyYW0ge1VTQUdFXyp9IHVzYWdlXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXIgfCBVaW50OEFycmF5fSBkYXRhXG4gICAqL1xuICBmdW5jdGlvbiBWZXJ0ZXhCdWZmZXIoZGV2aWNlLCBmb3JtYXQsIHVzYWdlLCBkYXRhKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZlcnRleEJ1ZmZlcik7XG5cbiAgICB0aGlzLl9kZXZpY2UgPSBkZXZpY2U7XG4gICAgdGhpcy5fZm9ybWF0ID0gZm9ybWF0O1xuICAgIHRoaXMuX3VzYWdlID0gdXNhZ2U7XG4gICAgdGhpcy5fYnl0ZXNQZXJWZXJ0ZXggPSB0aGlzLl9mb3JtYXQuX2J5dGVzO1xuICAgIHRoaXMuX2J5dGVzID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMuX251bVZlcnRpY2VzID0gdGhpcy5fYnl0ZXMgLyB0aGlzLl9ieXRlc1BlclZlcnRleDtcblxuICAgIHRoaXMuX25lZWRFeHBhbmREYXRhU3RvcmUgPSB0cnVlO1xuXG4gICAgLy8gdXBkYXRlXG4gICAgdGhpcy5fZ2xJRCA9IGRldmljZS5fZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgdGhpcy51cGRhdGUoMCwgZGF0YSk7XG5cbiAgICAvLyBzdGF0c1xuICAgIGRldmljZS5fc3RhdHMudmIgKz0gdGhpcy5fYnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQG1ldGhvZCBkZXN0cm95XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFZlcnRleEJ1ZmZlciwgW3tcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIGlmICh0aGlzLl9nbElEID09PSAtMSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgYnVmZmVyIGFscmVhZHkgZGVzdHJveWVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdsID0gdGhpcy5fZGV2aWNlLl9nbDtcbiAgICAgIGdsLmRlbGV0ZUJ1ZmZlcih0aGlzLl9nbElEKTtcbiAgICAgIHRoaXMuX2RldmljZS5fc3RhdHMudmIgLT0gdGhpcy5ieXRlcztcblxuICAgICAgdGhpcy5fZ2xJRCA9IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgdXBkYXRlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVPZmZzZXRcbiAgICAgKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShieXRlT2Zmc2V0LCBkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fZ2xJRCA9PT0gLTEpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignVGhlIGJ1ZmZlciBpcyBkZXN0cm95ZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5ieXRlTGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIC8vIE5lZWQgdG8gY3JlYXRlIG5ldyBidWZmZXIgb2JqZWN0IHdoZW4gYnl0ZXMgZXhjZWVkXG4gICAgICBpZiAoYnl0ZU9mZnNldCArIGRhdGEuYnl0ZUxlbmd0aCA+IHRoaXMuX2J5dGVzKSB7XG4gICAgICAgIGlmIChieXRlT2Zmc2V0KSB7XG4gICAgICAgICAgLy8gTG9zdCBkYXRhIGJldHdlZW4gWzAsIGJ5dGVPZmZzZXRdIHdoaWNoIGlzIG5lZWQgZm9yIG5ldyBidWZmZXJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gdXBkYXRlIGRhdGEsIGJ5dGVzIGV4Y2VlZC4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbmVlZEV4cGFuZERhdGFTdG9yZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fYnl0ZXMgPSBieXRlT2Zmc2V0ICsgZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIHRoaXMuX251bVZlcnRpY2VzID0gdGhpcy5fYnl0ZXMgLyB0aGlzLl9ieXRlc1BlclZlcnRleDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ2wgPSB0aGlzLl9kZXZpY2UuX2dsO1xuICAgICAgdmFyIGdsVXNhZ2UgPSB0aGlzLl91c2FnZTtcblxuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX2dsSUQpO1xuICAgICAgaWYgKHRoaXMuX25lZWRFeHBhbmREYXRhU3RvcmUpIHtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsVXNhZ2UpO1xuICAgICAgICB0aGlzLl9uZWVkRXhwYW5kRGF0YVN0b3JlID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgYnl0ZU9mZnNldCwgZGF0YSk7XG4gICAgICB9XG4gICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0Rm9ybWF0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rm9ybWF0KG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mb3JtYXQuZWxlbWVudChuYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRVc2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVzYWdlKHVzYWdlKSB7XG4gICAgICB0aGlzLl91c2FnZSA9IHVzYWdlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2NvdW50JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9udW1WZXJ0aWNlcztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmVydGV4QnVmZmVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBWZXJ0ZXhCdWZmZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluWmxjblJsZUMxaWRXWm1aWEl1YW5NaVhTd2libUZ0WlhNaU9sc2lWbVZ5ZEdWNFFuVm1abVZ5SWl3aVpHVjJhV05sSWl3aVptOXliV0YwSWl3aWRYTmhaMlVpTENKa1lYUmhJaXdpWDJSbGRtbGpaU0lzSWw5bWIzSnRZWFFpTENKZmRYTmhaMlVpTENKZllubDBaWE5RWlhKV1pYSjBaWGdpTENKZllubDBaWE1pTENKaWVYUmxUR1Z1WjNSb0lpd2lYMjUxYlZabGNuUnBZMlZ6SWl3aVgyNWxaV1JGZUhCaGJtUkVZWFJoVTNSdmNtVWlMQ0pmWjJ4SlJDSXNJbDluYkNJc0ltTnlaV0YwWlVKMVptWmxjaUlzSW5Wd1pHRjBaU0lzSWw5emRHRjBjeUlzSW5aaUlpd2lZMjl1YzI5c1pTSXNJbVZ5Y205eUlpd2laMndpTENKa1pXeGxkR1ZDZFdabVpYSWlMQ0ppZVhSbGN5SXNJbUo1ZEdWUFptWnpaWFFpTENKbmJGVnpZV2RsSWl3aVltbHVaRUoxWm1abGNpSXNJa0ZTVWtGWlgwSlZSa1pGVWlJc0ltSjFabVpsY2tSaGRHRWlMQ0ppZFdabVpYSlRkV0pFWVhSaElpd2libUZ0WlNJc0ltVnNaVzFsYm5RaVhTd2liV0Z3Y0dsdVozTWlPaUk3T3pzN096czdPMEZCUVVFN096czdTVUZGVFVFc1dUdEJRVU5LT3pzN096czdPMEZCVDBFc2QwSkJRVmxETEUxQlFWb3NSVUZCYjBKRExFMUJRWEJDTEVWQlFUUkNReXhMUVVFMVFpeEZRVUZ0UTBNc1NVRkJia01zUlVGQmVVTTdRVUZCUVRzN1FVRkRka01zVTBGQlMwTXNUMEZCVEN4SFFVRmxTaXhOUVVGbU8wRkJRMEVzVTBGQlMwc3NUMEZCVEN4SFFVRmxTaXhOUVVGbU8wRkJRMEVzVTBGQlMwc3NUVUZCVEN4SFFVRmpTaXhMUVVGa08wRkJRMEVzVTBGQlMwc3NaVUZCVEN4SFFVRjFRaXhMUVVGTFJpeFBRVUZNTEVOQlFXRkhMRTFCUVhCRE8wRkJRMEVzVTBGQlMwRXNUVUZCVEN4SFFVRmpUQ3hMUVVGTFRTeFZRVUZ1UWp0QlFVTkJMRk5CUVV0RExGbEJRVXdzUjBGQmIwSXNTMEZCUzBZc1RVRkJUQ3hIUVVGakxFdEJRVXRFTEdWQlFYWkRPenRCUVVWQkxGTkJRVXRKTEc5Q1FVRk1MRWRCUVRSQ0xFbEJRVFZDT3p0QlFVVkJPMEZCUTBFc1UwRkJTME1zUzBGQlRDeEhRVUZoV2l4UFFVRlBZU3hIUVVGUUxFTkJRVmRETEZsQlFWZ3NSVUZCWWp0QlFVTkJMRk5CUVV0RExFMUJRVXdzUTBGQldTeERRVUZhTEVWQlFXVmFMRWxCUVdZN08wRkJSVUU3UVVGRFFVZ3NWMEZCVDJkQ0xFMUJRVkFzUTBGQlkwTXNSVUZCWkN4SlFVRnZRaXhMUVVGTFZDeE5RVUY2UWp0QlFVTkVPenRCUVVWRU96czdPenM3T3poQ1FVZFZPMEZCUTFJc1ZVRkJTU3hMUVVGTFNTeExRVUZNTEV0QlFXVXNRMEZCUXl4RFFVRndRaXhGUVVGMVFqdEJRVU55UWswc1owSkJRVkZETEV0QlFWSXNRMEZCWXl3NFFrRkJaRHRCUVVOQk8wRkJRMFE3TzBGQlJVUXNWVUZCU1VNc1MwRkJTeXhMUVVGTGFFSXNUMEZCVEN4RFFVRmhVeXhIUVVGMFFqdEJRVU5CVHl4VFFVRkhReXhaUVVGSUxFTkJRV2RDTEV0QlFVdFVMRXRCUVhKQ08wRkJRMEVzVjBGQlMxSXNUMEZCVEN4RFFVRmhXU3hOUVVGaUxFTkJRVzlDUXl4RlFVRndRaXhKUVVFd1FpeExRVUZMU3l4TFFVRXZRanM3UVVGRlFTeFhRVUZMVml4TFFVRk1MRWRCUVdFc1EwRkJReXhEUVVGa08wRkJRMFE3TzBGQlJVUTdPenM3T3pzN096SkNRVXRQVnl4VkxFVkJRVmx3UWl4SkxFVkJRVTA3UVVGRGRrSXNWVUZCU1N4TFFVRkxVeXhMUVVGTUxFdEJRV1VzUTBGQlF5eERRVUZ3UWl4RlFVRjFRanRCUVVOeVFrMHNaMEpCUVZGRExFdEJRVklzUTBGQll5eDVRa0ZCWkR0QlFVTkJPMEZCUTBRN08wRkJSVVFzVlVGQlNXaENMRXRCUVV0TkxGVkJRVXdzUzBGQmIwSXNRMEZCZUVJc1JVRkJNa0k3TzBGQlJUTkNPMEZCUTBFc1ZVRkJTV01zWVVGQllYQkNMRXRCUVV0TkxGVkJRV3hDTEVkQlFTdENMRXRCUVV0RUxFMUJRWGhETEVWQlFXZEVPMEZCUXpsRExGbEJRVWxsTEZWQlFVb3NSVUZCWjBJN1FVRkRaRHRCUVVOQlRDeHJRa0ZCVVVNc1MwRkJVaXhEUVVGakxITkRRVUZrTzBGQlEwRTdRVUZEUkN4VFFVcEVMRTFCUzBzN1FVRkRTQ3hsUVVGTFVpeHZRa0ZCVEN4SFFVRTBRaXhKUVVFMVFqdEJRVU5CTEdWQlFVdElMRTFCUVV3c1IwRkJZMlVzWVVGQllYQkNMRXRCUVV0TkxGVkJRV2hETzBGQlEwRXNaVUZCUzBNc1dVRkJUQ3hIUVVGdlFpeExRVUZMUml4TlFVRk1MRWRCUVdNc1MwRkJTMFFzWlVGQmRrTTdRVUZEUkR0QlFVTkdPenRCUVVWRUxGVkJRVWxoTEV0QlFVc3NTMEZCUzJoQ0xFOUJRVXdzUTBGQllWTXNSMEZCZEVJN1FVRkRRU3hWUVVGSlZ5eFZRVUZWTEV0QlFVdHNRaXhOUVVGdVFqczdRVUZGUVdNc1UwRkJSMHNzVlVGQlNDeERRVUZqVEN4SFFVRkhUU3haUVVGcVFpeEZRVUVyUWl4TFFVRkxaQ3hMUVVGd1F6dEJRVU5CTEZWQlFVa3NTMEZCUzBRc2IwSkJRVlFzUlVGQkswSTdRVUZETjBKVExGZEJRVWRQTEZWQlFVZ3NRMEZCWTFBc1IwRkJSMDBzV1VGQmFrSXNSVUZCSzBKMlFpeEpRVUV2UWl4RlFVRnhRM0ZDTEU5QlFYSkRPMEZCUTBFc1lVRkJTMklzYjBKQlFVd3NSMEZCTkVJc1MwRkJOVUk3UVVGRFJDeFBRVWhFTEUxQlNVczdRVUZEU0ZNc1YwRkJSMUVzWVVGQlNDeERRVUZwUWxJc1IwRkJSMDBzV1VGQmNFSXNSVUZCYTBOSUxGVkJRV3hETEVWQlFUaERjRUlzU1VGQk9VTTdRVUZEUkR0QlFVTkVhVUlzVTBGQlIwc3NWVUZCU0N4RFFVRmpUQ3hIUVVGSFRTeFpRVUZxUWl4RlFVRXJRaXhKUVVFdlFqdEJRVU5FT3pzN09FSkJUVlZITEVrc1JVRkJUVHRCUVVObUxHRkJRVThzUzBGQlMzaENMRTlCUVV3c1EwRkJZWGxDTEU5QlFXSXNRMEZCY1VKRUxFbEJRWEpDTEVOQlFWQTdRVUZEUkRzN096WkNRVVZUTTBJc1N5eEZRVUZQTzBGQlEyWXNWMEZCUzBrc1RVRkJUQ3hIUVVGalNpeExRVUZrTzBGQlEwUTdPenQzUWtGV1dUdEJRVU5ZTEdGQlFVOHNTMEZCUzFFc1dVRkJXanRCUVVORU96czdPenM3YTBKQlYxbFlMRmtpTENKbWFXeGxJam9pZG1WeWRHVjRMV0oxWm1abGNpNXFjeUlzSW5OdmRYSmpaWE5EYjI1MFpXNTBJanBiSW1sdGNHOXlkQ0I3SUdWdWRXMXpJSDBnWm5KdmJTQW5MaTlsYm5WdGN5YzdYRzVjYm1Oc1lYTnpJRlpsY25SbGVFSjFabVpsY2lCN1hHNGdJQzhxS2x4dUlDQWdLaUJBWTI5dWMzUnlkV04wYjNKY2JpQWdJQ29nUUhCaGNtRnRJSHRFWlhacFkyVjlJR1JsZG1salpWeHVJQ0FnS2lCQWNHRnlZVzBnZTFabGNuUmxlRVp2Y20xaGRIMGdabTl5YldGMFhHNGdJQ0FxSUVCd1lYSmhiU0I3VlZOQlIwVmZLbjBnZFhOaFoyVmNiaUFnSUNvZ1FIQmhjbUZ0SUh0QmNuSmhlVUoxWm1abGNpQjhJRlZwYm5RNFFYSnlZWGw5SUdSaGRHRmNiaUFnSUNvdlhHNGdJR052Ym5OMGNuVmpkRzl5S0dSbGRtbGpaU3dnWm05eWJXRjBMQ0IxYzJGblpTd2daR0YwWVNrZ2UxeHVJQ0FnSUhSb2FYTXVYMlJsZG1salpTQTlJR1JsZG1salpUdGNiaUFnSUNCMGFHbHpMbDltYjNKdFlYUWdQU0JtYjNKdFlYUTdYRzRnSUNBZ2RHaHBjeTVmZFhOaFoyVWdQU0IxYzJGblpUdGNiaUFnSUNCMGFHbHpMbDlpZVhSbGMxQmxjbFpsY25SbGVDQTlJSFJvYVhNdVgyWnZjbTFoZEM1ZllubDBaWE03WEc0Z0lDQWdkR2hwY3k1ZllubDBaWE1nUFNCa1lYUmhMbUo1ZEdWTVpXNW5kR2c3WEc0Z0lDQWdkR2hwY3k1ZmJuVnRWbVZ5ZEdsalpYTWdQU0IwYUdsekxsOWllWFJsY3lBdklIUm9hWE11WDJKNWRHVnpVR1Z5Vm1WeWRHVjRPMXh1WEc0Z0lDQWdkR2hwY3k1ZmJtVmxaRVY0Y0dGdVpFUmhkR0ZUZEc5eVpTQTlJSFJ5ZFdVN1hHNWNiaUFnSUNBdkx5QjFjR1JoZEdWY2JpQWdJQ0IwYUdsekxsOW5iRWxFSUQwZ1pHVjJhV05sTGw5bmJDNWpjbVZoZEdWQ2RXWm1aWElvS1R0Y2JpQWdJQ0IwYUdsekxuVndaR0YwWlNnd0xDQmtZWFJoS1R0Y2JseHVJQ0FnSUM4dklITjBZWFJ6WEc0Z0lDQWdaR1YyYVdObExsOXpkR0YwY3k1MllpQXJQU0IwYUdsekxsOWllWFJsY3p0Y2JpQWdmVnh1WEc0Z0lDOHFLbHh1SUNBZ0tpQkFiV1YwYUc5a0lHUmxjM1J5YjNsY2JpQWdJQ292WEc0Z0lHUmxjM1J5YjNrb0tTQjdYRzRnSUNBZ2FXWWdLSFJvYVhNdVgyZHNTVVFnUFQwOUlDMHhLU0I3WEc0Z0lDQWdJQ0JqYjI1emIyeGxMbVZ5Y205eUtDZFVhR1VnWW5WbVptVnlJR0ZzY21WaFpIa2daR1Z6ZEhKdmVXVmtKeWs3WEc0Z0lDQWdJQ0J5WlhSMWNtNDdYRzRnSUNBZ2ZWeHVYRzRnSUNBZ2JHVjBJR2RzSUQwZ2RHaHBjeTVmWkdWMmFXTmxMbDluYkR0Y2JpQWdJQ0JuYkM1a1pXeGxkR1ZDZFdabVpYSW9kR2hwY3k1ZloyeEpSQ2s3WEc0Z0lDQWdkR2hwY3k1ZlpHVjJhV05sTGw5emRHRjBjeTUyWWlBdFBTQjBhR2x6TG1KNWRHVnpPMXh1WEc0Z0lDQWdkR2hwY3k1ZloyeEpSQ0E5SUMweE8xeHVJQ0I5WEc1Y2JpQWdMeW9xWEc0Z0lDQXFJRUJ0WlhSb2IyUWdkWEJrWVhSbFhHNGdJQ0FxSUVCd1lYSmhiU0I3VG5WdFltVnlmU0JpZVhSbFQyWm1jMlYwWEc0Z0lDQXFJRUJ3WVhKaGJTQjdRWEp5WVhsQ2RXWm1aWEo5SUdSaGRHRmNiaUFnSUNvdlhHNGdJSFZ3WkdGMFpTaGllWFJsVDJabWMyVjBMQ0JrWVhSaEtTQjdYRzRnSUNBZ2FXWWdLSFJvYVhNdVgyZHNTVVFnUFQwOUlDMHhLU0I3WEc0Z0lDQWdJQ0JqYjI1emIyeGxMbVZ5Y205eUtDZFVhR1VnWW5WbVptVnlJR2x6SUdSbGMzUnliM2xsWkNjcE8xeHVJQ0FnSUNBZ2NtVjBkWEp1TzF4dUlDQWdJSDFjYmx4dUlDQWdJR2xtSUNoa1lYUmhMbUo1ZEdWTVpXNW5kR2dnUFQwOUlEQXBJSEpsZEhWeWJqdGNibHh1SUNBZ0lDOHZJRTVsWldRZ2RHOGdZM0psWVhSbElHNWxkeUJpZFdabVpYSWdiMkpxWldOMElIZG9aVzRnWW5sMFpYTWdaWGhqWldWa1hHNGdJQ0FnYVdZZ0tHSjVkR1ZQWm1aelpYUWdLeUJrWVhSaExtSjVkR1ZNWlc1bmRHZ2dQaUIwYUdsekxsOWllWFJsY3lrZ2UxeHVJQ0FnSUNBZ2FXWWdLR0o1ZEdWUFptWnpaWFFwSUh0Y2JpQWdJQ0FnSUNBZ0x5OGdURzl6ZENCa1lYUmhJR0psZEhkbFpXNGdXekFzSUdKNWRHVlBabVp6WlhSZElIZG9hV05vSUdseklHNWxaV1FnWm05eUlHNWxkeUJpZFdabVpYSmNiaUFnSUNBZ0lDQWdZMjl1YzI5c1pTNWxjbkp2Y2lnblJtRnBiR1ZrSUhSdklIVndaR0YwWlNCa1lYUmhMQ0JpZVhSbGN5QmxlR05sWldRdUp5azdYRzRnSUNBZ0lDQWdJSEpsZEhWeWJqdGNiaUFnSUNBZ0lIMWNiaUFnSUNBZ0lHVnNjMlVnZTF4dUlDQWdJQ0FnSUNCMGFHbHpMbDl1WldWa1JYaHdZVzVrUkdGMFlWTjBiM0psSUQwZ2RISjFaVHRjYmlBZ0lDQWdJQ0FnZEdocGN5NWZZbmwwWlhNZ1BTQmllWFJsVDJabWMyVjBJQ3NnWkdGMFlTNWllWFJsVEdWdVozUm9PMXh1SUNBZ0lDQWdJQ0IwYUdsekxsOXVkVzFXWlhKMGFXTmxjeUE5SUhSb2FYTXVYMko1ZEdWeklDOGdkR2hwY3k1ZllubDBaWE5RWlhKV1pYSjBaWGc3WEc0Z0lDQWdJQ0I5WEc0Z0lDQWdmVnh1WEc0Z0lDQWdiR1YwSUdkc0lEMGdkR2hwY3k1ZlpHVjJhV05sTGw5bmJEdGNiaUFnSUNCc1pYUWdaMnhWYzJGblpTQTlJSFJvYVhNdVgzVnpZV2RsTzF4dVhHNGdJQ0FnWjJ3dVltbHVaRUoxWm1abGNpaG5iQzVCVWxKQldWOUNWVVpHUlZJc0lIUm9hWE11WDJkc1NVUXBPMXh1SUNBZ0lHbG1JQ2gwYUdsekxsOXVaV1ZrUlhod1lXNWtSR0YwWVZOMGIzSmxLU0I3WEc0Z0lDQWdJQ0JuYkM1aWRXWm1aWEpFWVhSaEtHZHNMa0ZTVWtGWlgwSlZSa1pGVWl3Z1pHRjBZU3dnWjJ4VmMyRm5aU2s3WEc0Z0lDQWdJQ0IwYUdsekxsOXVaV1ZrUlhod1lXNWtSR0YwWVZOMGIzSmxJRDBnWm1Gc2MyVTdYRzRnSUNBZ2ZWeHVJQ0FnSUdWc2MyVWdlMXh1SUNBZ0lDQWdaMnd1WW5WbVptVnlVM1ZpUkdGMFlTaG5iQzVCVWxKQldWOUNWVVpHUlZJc0lHSjVkR1ZQWm1aelpYUXNJR1JoZEdFcE8xeHVJQ0FnSUgxY2JpQWdJQ0JuYkM1aWFXNWtRblZtWm1WeUtHZHNMa0ZTVWtGWlgwSlZSa1pGVWl3Z2JuVnNiQ2s3WEc0Z0lIMWNibHh1SUNCblpYUWdZMjkxYm5RZ0tDa2dlMXh1SUNBZ0lISmxkSFZ5YmlCMGFHbHpMbDl1ZFcxV1pYSjBhV05sY3p0Y2JpQWdmVnh1WEc0Z0lHZGxkRVp2Y20xaGRDQW9ibUZ0WlNrZ2UxeHVJQ0FnSUhKbGRIVnliaUIwYUdsekxsOW1iM0p0WVhRdVpXeGxiV1Z1ZENodVlXMWxLVHRjYmlBZ2ZWeHVYRzRnSUhObGRGVnpZV2RsSUNoMWMyRm5aU2tnZTF4dUlDQWdJSFJvYVhNdVgzVnpZV2RsSUQwZ2RYTmhaMlU3WEc0Z0lIMWNibjFjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnVm1WeWRHVjRRblZtWm1WeU8xeHVJbDE5Il19