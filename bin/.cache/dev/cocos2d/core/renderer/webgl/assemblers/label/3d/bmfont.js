(function () {
    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
    var __module = nodeEnv ? module : { exports: {} };
    var __filename = 'engine-dev/cocos2d/core/renderer/webgl/assemblers/label/3d/bmfont.js';
    var __require = nodeEnv ? function (request) {
        return require(request);
    } : function (request) {
        return __quick_compile__.require(request, __filename);
    };
    function __define(exports, require, module) {
        if (!nodeEnv) {
            __quick_compile__.registerModule(__filename, module);
        }
                'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function');
            }
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
            }
            return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
                throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Assembler3D = require('../../../../assembler-3d');
        var WebglBmfontAssembler = require('../2d/bmfont');
        var vec3 = cc.vmath.vec3;
        var vec3_temp_local = vec3.create();
        var vec3_temp_world = vec3.create();
        var WebglBmfontAssembler3D = function (_WebglBmfontAssembler) {
            _inherits(WebglBmfontAssembler3D, _WebglBmfontAssembler);
            function WebglBmfontAssembler3D() {
                _classCallCheck(this, WebglBmfontAssembler3D);
                return _possibleConstructorReturn(this, (WebglBmfontAssembler3D.__proto__ || Object.getPrototypeOf(WebglBmfontAssembler3D)).apply(this, arguments));
            }
            return WebglBmfontAssembler3D;
        }(WebglBmfontAssembler);
        exports.default = WebglBmfontAssembler3D;
        cc.js.mixin(WebglBmfontAssembler3D.prototype, Assembler3D, {
            updateWorldVerts: function updateWorldVerts(comp) {
                var matrix = comp.node._worldMatrix;
                var local = this._local;
                var world = this._renderData.vDatas[0];
                var floatsPerVert = this.floatsPerVert;
                for (var offset = 0; offset < world.length; offset += floatsPerVert) {
                    vec3.set(vec3_temp_local, local[offset], local[offset + 1], 0);
                    vec3.transformMat4(vec3_temp_world, vec3_temp_local, matrix);
                    world[offset] = vec3_temp_world.x;
                    world[offset + 1] = vec3_temp_world.y;
                    world[offset + 2] = vec3_temp_world.z;
                }
            }
        });
        module.exports = exports['default'];
    }
    if (nodeEnv) {
        __define(__module.exports, __require, __module);
    } else {
        __quick_compile__.registerModuleFunc(__filename, function () {
            __define(__module.exports, __require, __module);
        });
    }
}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImJtZm9udC5qcyIsIi9Vc2Vycy9TaGFyZWQvYmluZ29fZnJlbnp5L2VuZ2luZS9jb2NvczJkL2NvcmUvcmVuZGVyZXIvd2ViZ2wvYXNzZW1ibGVycy9sYWJlbC8zZC9ibWZvbnQuanMiXSwibmFtZXMiOlsiQXNzZW1ibGVyM0QiLCJyZXF1aXJlIiwiV2ViZ2xCbWZvbnRBc3NlbWJsZXIiLCJ2ZWMzIiwiY2MiLCJ2bWF0aCIsInZlYzNfdGVtcF9sb2NhbCIsImNyZWF0ZSIsInZlYzNfdGVtcF93b3JsZCIsIldlYmdsQm1mb250QXNzZW1ibGVyM0QiLCJqcyIsIm1peGluIiwicHJvdG90eXBlIiwidXBkYXRlV29ybGRWZXJ0cyIsImNvbXAiLCJtYXRyaXgiLCJub2RlIiwiX3dvcmxkTWF0cml4IiwibG9jYWwiLCJfbG9jYWwiLCJ3b3JsZCIsIl9yZW5kZXJEYXRhIiwidkRhdGFzIiwiZmxvYXRzUGVyVmVydCIsIm9mZnNldCIsImxlbmd0aCIsInNldCIsInRyYW5zZm9ybU1hdDQiLCJ4IiwieSIsInoiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBeUJBLElBQU1BLFdBQUFBLEdBQWNDLE9BQUFBLENBQVEsMEJBQVJBLENBQXBCO1FBQ0EsSUFBTUMsb0JBQUFBLEdBQXVCRCxPQUFBQSxDQUFRLGNBQVJBLENBQTdCO1FBRUEsSUFBTUUsSUFBQUEsR0FBT0MsRUFBQUEsQ0FBR0MsS0FBSEQsQ0FBU0QsSUFBdEI7UUFFQSxJQUFNRyxlQUFBQSxHQUFrQkgsSUFBQUEsQ0FBS0ksTUFBTEosRUFBeEI7UUFDQSxJQUFNSyxlQUFBQSxHQUFrQkwsSUFBQUEsQ0FBS0ksTUFBTEosRUFBeEI7WUFFcUJNLHNCQUFBQTs7Ozs7OztVQUErQlA7MEJBQS9CTztRQUlyQkwsRUFBQUEsQ0FBR00sRUFBSE4sQ0FBTU8sS0FBTlAsQ0FBWUssc0JBQUFBLENBQXVCRyxTQUFuQ1IsRUFBOENKLFdBQTlDSSxFQUEyRDtBQUFBLFlBQ3ZEUyxnQkFBQUEsRUFEdUQsU0FBQSxnQkFBQSxDQUNyQ0MsSUFEcUMsRUFDL0I7QUFBQSxnQkFDcEIsSUFBSUMsTUFBQUEsR0FBU0QsSUFBQUEsQ0FBS0UsSUFBTEYsQ0FBVUcsWUFBdkIsQ0FEb0I7QUFBQSxnQkFFcEIsSUFBSUMsS0FBQUEsR0FBUSxLQUFLQyxNQUFqQixDQUZvQjtBQUFBLGdCQUdwQixJQUFJQyxLQUFBQSxHQUFRLEtBQUtDLFdBQUwsQ0FBaUJDLE1BQWpCLENBQXdCLENBQXhCLENBQVosQ0FIb0I7QUFBQSxnQkFLcEIsSUFBSUMsYUFBQUEsR0FBZ0IsS0FBS0EsYUFBekIsQ0FMb0I7QUFBQSxnQkFNcEIsS0FBSyxJQUFJQyxNQUFBQSxHQUFTLENBQWIsQ0FBTCxDQUFxQkEsTUFBQUEsR0FBU0osS0FBQUEsQ0FBTUssTUFBcEMsRUFBNENELE1BQUFBLElBQVVELGFBQXRELEVBQXFFO0FBQUEsb0JBQ2pFcEIsSUFBQUEsQ0FBS3VCLEdBQUx2QixDQUFTRyxlQUFUSCxFQUEwQmUsS0FBQUEsQ0FBTU0sTUFBTk4sQ0FBMUJmLEVBQXlDZSxLQUFBQSxDQUFNTSxNQUFBQSxHQUFPLENBQWJOLENBQXpDZixFQUEwRCxDQUExREEsRUFEaUU7QUFBQSxvQkFFakVBLElBQUFBLENBQUt3QixhQUFMeEIsQ0FBbUJLLGVBQW5CTCxFQUFvQ0csZUFBcENILEVBQXFEWSxNQUFyRFosRUFGaUU7QUFBQSxvQkFJakVpQixLQUFBQSxDQUFNSSxNQUFOSixJQUFnQlosZUFBQUEsQ0FBZ0JvQixDQUFoQ1IsQ0FKaUU7QUFBQSxvQkFLakVBLEtBQUFBLENBQU1JLE1BQUFBLEdBQU8sQ0FBYkosSUFBa0JaLGVBQUFBLENBQWdCcUIsQ0FBbENULENBTGlFO0FBQUEsb0JBTWpFQSxLQUFBQSxDQUFNSSxNQUFBQSxHQUFPLENBQWJKLElBQWtCWixlQUFBQSxDQUFnQnNCLENBQWxDVixDQU5pRTtBQUFBLGlCQU5qRDtBQUFBLGFBRCtCO0FBQUEsU0FBM0RoQiIsImZpbGUiOiJibWZvbnQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLlxuXG4gaHR0cHM6Ly93d3cuY29jb3MuY29tL1xuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxuIHdvcmxkd2lkZSwgcm95YWx0eS1mcmVlLCBub24tYXNzaWduYWJsZSwgcmV2b2NhYmxlIGFuZCBub24tZXhjbHVzaXZlIGxpY2Vuc2VcbiB0byB1c2UgQ29jb3MgQ3JlYXRvciBzb2xlbHkgdG8gZGV2ZWxvcCBnYW1lcyBvbiB5b3VyIHRhcmdldCBwbGF0Zm9ybXMuIFlvdSBzaGFsbFxuIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcbiB1c2VkIGZvciBkZXZlbG9waW5nIGdhbWVzLiBZb3UgYXJlIG5vdCBncmFudGVkIHRvIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXG4gc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIENvY29zIENyZWF0b3IuXG5cbiBUaGUgc29mdHdhcmUgb3IgdG9vbHMgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBhcmUgbGljZW5zZWQsIG5vdCBzb2xkLlxuIFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLiByZXNlcnZlcyBhbGwgcmlnaHRzIG5vdCBleHByZXNzbHkgZ3JhbnRlZCB0byB5b3UuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuIFRIRSBTT0ZUV0FSRS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jb25zdCBBc3NlbWJsZXIzRCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2Fzc2VtYmxlci0zZCcpO1xuY29uc3QgV2ViZ2xCbWZvbnRBc3NlbWJsZXIgPSByZXF1aXJlKCcuLi8yZC9ibWZvbnQnKTtcblxuY29uc3QgdmVjMyA9IGNjLnZtYXRoLnZlYzM7XG5cbmNvbnN0IHZlYzNfdGVtcF9sb2NhbCA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCB2ZWMzX3RlbXBfd29ybGQgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJnbEJtZm9udEFzc2VtYmxlcjNEIGV4dGVuZHMgV2ViZ2xCbWZvbnRBc3NlbWJsZXIge1xuXG59XG5cbmNjLmpzLm1peGluKFdlYmdsQm1mb250QXNzZW1ibGVyM0QucHJvdG90eXBlLCBBc3NlbWJsZXIzRCwge1xuICAgIHVwZGF0ZVdvcmxkVmVydHMgKGNvbXApIHtcbiAgICAgICAgbGV0IG1hdHJpeCA9IGNvbXAubm9kZS5fd29ybGRNYXRyaXg7XG4gICAgICAgIGxldCBsb2NhbCA9IHRoaXMuX2xvY2FsO1xuICAgICAgICBsZXQgd29ybGQgPSB0aGlzLl9yZW5kZXJEYXRhLnZEYXRhc1swXTtcblxuICAgICAgICBsZXQgZmxvYXRzUGVyVmVydCA9IHRoaXMuZmxvYXRzUGVyVmVydDtcbiAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgd29ybGQubGVuZ3RoOyBvZmZzZXQgKz0gZmxvYXRzUGVyVmVydCkge1xuICAgICAgICAgICAgdmVjMy5zZXQodmVjM190ZW1wX2xvY2FsLCBsb2NhbFtvZmZzZXRdLCBsb2NhbFtvZmZzZXQrMV0sIDApO1xuICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHZlYzNfdGVtcF93b3JsZCwgdmVjM190ZW1wX2xvY2FsLCBtYXRyaXgpO1xuXG4gICAgICAgICAgICB3b3JsZFtvZmZzZXRdID0gdmVjM190ZW1wX3dvcmxkLng7XG4gICAgICAgICAgICB3b3JsZFtvZmZzZXQrMV0gPSB2ZWMzX3RlbXBfd29ybGQueTtcbiAgICAgICAgICAgIHdvcmxkW29mZnNldCsyXSA9IHZlYzNfdGVtcF93b3JsZC56O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLlxuXG4gaHR0cHM6Ly93d3cuY29jb3MuY29tL1xuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxuIHdvcmxkd2lkZSwgcm95YWx0eS1mcmVlLCBub24tYXNzaWduYWJsZSwgcmV2b2NhYmxlIGFuZCBub24tZXhjbHVzaXZlIGxpY2Vuc2VcbiB0byB1c2UgQ29jb3MgQ3JlYXRvciBzb2xlbHkgdG8gZGV2ZWxvcCBnYW1lcyBvbiB5b3VyIHRhcmdldCBwbGF0Zm9ybXMuIFlvdSBzaGFsbFxuIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcbiB1c2VkIGZvciBkZXZlbG9waW5nIGdhbWVzLiBZb3UgYXJlIG5vdCBncmFudGVkIHRvIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXG4gc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIENvY29zIENyZWF0b3IuXG5cbiBUaGUgc29mdHdhcmUgb3IgdG9vbHMgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBhcmUgbGljZW5zZWQsIG5vdCBzb2xkLlxuIFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLiByZXNlcnZlcyBhbGwgcmlnaHRzIG5vdCBleHByZXNzbHkgZ3JhbnRlZCB0byB5b3UuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuIFRIRSBTT0ZUV0FSRS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgQXNzZW1ibGVyM0QgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9hc3NlbWJsZXItM2QnKTtcbnZhciBXZWJnbEJtZm9udEFzc2VtYmxlciA9IHJlcXVpcmUoJy4uLzJkL2JtZm9udCcpO1xuXG52YXIgdmVjMyA9IGNjLnZtYXRoLnZlYzM7XG5cbnZhciB2ZWMzX3RlbXBfbG9jYWwgPSB2ZWMzLmNyZWF0ZSgpO1xudmFyIHZlYzNfdGVtcF93b3JsZCA9IHZlYzMuY3JlYXRlKCk7XG5cbnZhciBXZWJnbEJtZm9udEFzc2VtYmxlcjNEID0gZnVuY3Rpb24gKF9XZWJnbEJtZm9udEFzc2VtYmxlcikge1xuICAgIF9pbmhlcml0cyhXZWJnbEJtZm9udEFzc2VtYmxlcjNELCBfV2ViZ2xCbWZvbnRBc3NlbWJsZXIpO1xuXG4gICAgZnVuY3Rpb24gV2ViZ2xCbWZvbnRBc3NlbWJsZXIzRCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYmdsQm1mb250QXNzZW1ibGVyM0QpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV2ViZ2xCbWZvbnRBc3NlbWJsZXIzRC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFdlYmdsQm1mb250QXNzZW1ibGVyM0QpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gV2ViZ2xCbWZvbnRBc3NlbWJsZXIzRDtcbn0oV2ViZ2xCbWZvbnRBc3NlbWJsZXIpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBXZWJnbEJtZm9udEFzc2VtYmxlcjNEO1xuXG5cbmNjLmpzLm1peGluKFdlYmdsQm1mb250QXNzZW1ibGVyM0QucHJvdG90eXBlLCBBc3NlbWJsZXIzRCwge1xuICAgIHVwZGF0ZVdvcmxkVmVydHM6IGZ1bmN0aW9uIHVwZGF0ZVdvcmxkVmVydHMoY29tcCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gY29tcC5ub2RlLl93b3JsZE1hdHJpeDtcbiAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5fbG9jYWw7XG4gICAgICAgIHZhciB3b3JsZCA9IHRoaXMuX3JlbmRlckRhdGEudkRhdGFzWzBdO1xuXG4gICAgICAgIHZhciBmbG9hdHNQZXJWZXJ0ID0gdGhpcy5mbG9hdHNQZXJWZXJ0O1xuICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCB3b3JsZC5sZW5ndGg7IG9mZnNldCArPSBmbG9hdHNQZXJWZXJ0KSB7XG4gICAgICAgICAgICB2ZWMzLnNldCh2ZWMzX3RlbXBfbG9jYWwsIGxvY2FsW29mZnNldF0sIGxvY2FsW29mZnNldCArIDFdLCAwKTtcbiAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NCh2ZWMzX3RlbXBfd29ybGQsIHZlYzNfdGVtcF9sb2NhbCwgbWF0cml4KTtcblxuICAgICAgICAgICAgd29ybGRbb2Zmc2V0XSA9IHZlYzNfdGVtcF93b3JsZC54O1xuICAgICAgICAgICAgd29ybGRbb2Zmc2V0ICsgMV0gPSB2ZWMzX3RlbXBfd29ybGQueTtcbiAgICAgICAgICAgIHdvcmxkW29mZnNldCArIDJdID0gdmVjM190ZW1wX3dvcmxkLno7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW1KdFptOXVkQzVxY3lKZExDSnVZVzFsY3lJNld5SkJjM05sYldKc1pYSXpSQ0lzSW5KbGNYVnBjbVVpTENKWFpXSm5iRUp0Wm05dWRFRnpjMlZ0WW14bGNpSXNJblpsWXpNaUxDSmpZeUlzSW5adFlYUm9JaXdpZG1Wak0xOTBaVzF3WDJ4dlkyRnNJaXdpWTNKbFlYUmxJaXdpZG1Wak0xOTBaVzF3WDNkdmNteGtJaXdpVjJWaVoyeENiV1p2Ym5SQmMzTmxiV0pzWlhJelJDSXNJbXB6SWl3aWJXbDRhVzRpTENKd2NtOTBiM1I1Y0dVaUxDSjFjR1JoZEdWWGIzSnNaRlpsY25Seklpd2lZMjl0Y0NJc0ltMWhkSEpwZUNJc0ltNXZaR1VpTENKZmQyOXliR1JOWVhSeWFYZ2lMQ0pzYjJOaGJDSXNJbDlzYjJOaGJDSXNJbmR2Y214a0lpd2lYM0psYm1SbGNrUmhkR0VpTENKMlJHRjBZWE1pTENKbWJHOWhkSE5RWlhKV1pYSjBJaXdpYjJabWMyVjBJaXdpYkdWdVozUm9JaXdpYzJWMElpd2lkSEpoYm5ObWIzSnRUV0YwTkNJc0luZ2lMQ0o1SWl3aWVpSmRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN08wRkJRVUU3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdRVUY1UWtFc1NVRkJUVUVzWTBGQlkwTXNVVUZCVVN3d1FrRkJVaXhEUVVGd1FqdEJRVU5CTEVsQlFVMURMSFZDUVVGMVFrUXNVVUZCVVN4alFVRlNMRU5CUVRkQ096dEJRVVZCTEVsQlFVMUZMRTlCUVU5RExFZEJRVWRETEV0QlFVZ3NRMEZCVTBZc1NVRkJkRUk3TzBGQlJVRXNTVUZCVFVjc2EwSkJRV3RDU0N4TFFVRkxTU3hOUVVGTUxFVkJRWGhDTzBGQlEwRXNTVUZCVFVNc2EwSkJRV3RDVEN4TFFVRkxTU3hOUVVGTUxFVkJRWGhDT3p0SlFVVnhRa1VzYzBJN096czdPenM3T3pzN1JVRkJLMEpRTEc5Q096dHJRa0ZCTDBKUExITkNPenM3UVVGSmNrSk1MRWRCUVVkTkxFVkJRVWdzUTBGQlRVTXNTMEZCVGl4RFFVRlpSaXgxUWtGQmRVSkhMRk5CUVc1RExFVkJRVGhEV2l4WFFVRTVReXhGUVVFeVJEdEJRVU4yUkdFc2IwSkJSSFZFTERSQ1FVTnlRME1zU1VGRWNVTXNSVUZETDBJN1FVRkRjRUlzV1VGQlNVTXNVMEZCVTBRc1MwRkJTMFVzU1VGQlRDeERRVUZWUXl4WlFVRjJRanRCUVVOQkxGbEJRVWxETEZGQlFWRXNTMEZCUzBNc1RVRkJha0k3UVVGRFFTeFpRVUZKUXl4UlFVRlJMRXRCUVV0RExGZEJRVXdzUTBGQmFVSkRMRTFCUVdwQ0xFTkJRWGRDTEVOQlFYaENMRU5CUVZvN08wRkJSVUVzV1VGQlNVTXNaMEpCUVdkQ0xFdEJRVXRCTEdGQlFYcENPMEZCUTBFc1lVRkJTeXhKUVVGSlF5eFRRVUZUTEVOQlFXeENMRVZCUVhGQ1FTeFRRVUZUU2l4TlFVRk5TeXhOUVVGd1F5eEZRVUUwUTBRc1ZVRkJWVVFzWVVGQmRFUXNSVUZCY1VVN1FVRkRha1Z3UWl4cFFrRkJTM1ZDTEVkQlFVd3NRMEZCVTNCQ0xHVkJRVlFzUlVGQk1FSlpMRTFCUVUxTkxFMUJRVTRzUTBGQk1VSXNSVUZCZVVOT0xFMUJRVTFOTEZOQlFVOHNRMEZCWWl4RFFVRjZReXhGUVVFd1JDeERRVUV4UkR0QlFVTkJja0lzYVVKQlFVdDNRaXhoUVVGTUxFTkJRVzFDYmtJc1pVRkJia0lzUlVGQmIwTkdMR1ZCUVhCRExFVkJRWEZFVXl4TlFVRnlSRHM3UVVGRlFVc3NhMEpCUVUxSkxFMUJRVTRzU1VGQlowSm9RaXhuUWtGQlowSnZRaXhEUVVGb1F6dEJRVU5CVWl4clFrRkJUVWtzVTBGQlR5eERRVUZpTEVsQlFXdENhRUlzWjBKQlFXZENjVUlzUTBGQmJFTTdRVUZEUVZRc2EwSkJRVTFKTEZOQlFVOHNRMEZCWWl4SlFVRnJRbWhDTEdkQ1FVRm5Rbk5DTEVOQlFXeERPMEZCUTBnN1FVRkRTanRCUVdaelJDeERRVUV6UkNJc0ltWnBiR1VpT2lKaWJXWnZiblF1YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2x4dUlFTnZjSGx5YVdkb2RDQW9ZeWtnTWpBeE55MHlNREU0SUZocFlXMWxiaUJaWVdwcElGTnZablIzWVhKbElFTnZMaXdnVEhSa0xseHVYRzRnYUhSMGNITTZMeTkzZDNjdVkyOWpiM011WTI5dEwxeHVYRzRnVUdWeWJXbHpjMmx2YmlCcGN5Qm9aWEpsWW5rZ1ozSmhiblJsWkN3Z1puSmxaU0J2WmlCamFHRnlaMlVzSUhSdklHRnVlU0J3WlhKemIyNGdiMkowWVdsdWFXNW5JR0VnWTI5d2VWeHVJRzltSUhSb2FYTWdjMjltZEhkaGNtVWdZVzVrSUdGemMyOWphV0YwWldRZ1pXNW5hVzVsSUhOdmRYSmpaU0JqYjJSbElDaDBhR1VnWENKVGIyWjBkMkZ5WlZ3aUtTd2dZU0JzYVcxcGRHVmtMRnh1SUhkdmNteGtkMmxrWlN3Z2NtOTVZV3gwZVMxbWNtVmxMQ0J1YjI0dFlYTnphV2R1WVdKc1pTd2djbVYyYjJOaFlteGxJR0Z1WkNCdWIyNHRaWGhqYkhWemFYWmxJR3hwWTJWdWMyVmNiaUIwYnlCMWMyVWdRMjlqYjNNZ1EzSmxZWFJ2Y2lCemIyeGxiSGtnZEc4Z1pHVjJaV3h2Y0NCbllXMWxjeUJ2YmlCNWIzVnlJSFJoY21kbGRDQndiR0YwWm05eWJYTXVJRmx2ZFNCemFHRnNiRnh1SUc1dmRDQjFjMlVnUTI5amIzTWdRM0psWVhSdmNpQnpiMlowZDJGeVpTQm1iM0lnWkdWMlpXeHZjR2x1WnlCdmRHaGxjaUJ6YjJaMGQyRnlaU0J2Y2lCMGIyOXNjeUIwYUdGMEozTmNiaUIxYzJWa0lHWnZjaUJrWlhabGJHOXdhVzVuSUdkaGJXVnpMaUJaYjNVZ1lYSmxJRzV2ZENCbmNtRnVkR1ZrSUhSdklIQjFZbXhwYzJnc0lHUnBjM1J5YVdKMWRHVXNYRzRnYzNWaWJHbGpaVzV6WlN3Z1lXNWtMMjl5SUhObGJHd2dZMjl3YVdWeklHOW1JRU52WTI5eklFTnlaV0YwYjNJdVhHNWNiaUJVYUdVZ2MyOW1kSGRoY21VZ2IzSWdkRzl2YkhNZ2FXNGdkR2hwY3lCTWFXTmxibk5sSUVGbmNtVmxiV1Z1ZENCaGNtVWdiR2xqWlc1elpXUXNJRzV2ZENCemIyeGtMbHh1SUZocFlXMWxiaUJaWVdwcElGTnZablIzWVhKbElFTnZMaXdnVEhSa0xpQnlaWE5sY25abGN5QmhiR3dnY21sbmFIUnpJRzV2ZENCbGVIQnlaWE56YkhrZ1ozSmhiblJsWkNCMGJ5QjViM1V1WEc1Y2JpQlVTRVVnVTA5R1ZGZEJVa1VnU1ZNZ1VGSlBWa2xFUlVRZ1hDSkJVeUJKVTF3aUxDQlhTVlJJVDFWVUlGZEJVbEpCVGxSWklFOUdJRUZPV1NCTFNVNUVMQ0JGV0ZCU1JWTlRJRTlTWEc0Z1NVMVFURWxGUkN3Z1NVNURURlZFU1U1SElFSlZWQ0JPVDFRZ1RFbE5TVlJGUkNCVVR5QlVTRVVnVjBGU1VrRk9WRWxGVXlCUFJpQk5SVkpEU0VGT1ZFRkNTVXhKVkZrc1hHNGdSa2xVVGtWVFV5QkdUMUlnUVNCUVFWSlVTVU5WVEVGU0lGQlZVbEJQVTBVZ1FVNUVJRTVQVGtsT1JsSkpUa2RGVFVWT1ZDNGdTVTRnVGs4Z1JWWkZUbFFnVTBoQlRFd2dWRWhGWEc0Z1FWVlVTRTlTVXlCUFVpQkRUMUJaVWtsSFNGUWdTRTlNUkVWU1V5QkNSU0JNU1VGQ1RFVWdSazlTSUVGT1dTQkRURUZKVFN3Z1JFRk5RVWRGVXlCUFVpQlBWRWhGVWx4dUlFeEpRVUpKVEVsVVdTd2dWMGhGVkVoRlVpQkpUaUJCVGlCQlExUkpUMDRnVDBZZ1EwOU9WRkpCUTFRc0lGUlBVbFFnVDFJZ1QxUklSVkpYU1ZORkxDQkJVa2xUU1U1SElFWlNUMDBzWEc0Z1QxVlVJRTlHSUU5U0lFbE9JRU5QVGs1RlExUkpUMDRnVjBsVVNDQlVTRVVnVTA5R1ZGZEJVa1VnVDFJZ1ZFaEZJRlZUUlNCUFVpQlBWRWhGVWlCRVJVRk1TVTVIVXlCSlRseHVJRlJJUlNCVFQwWlVWMEZTUlM1Y2JpQXFLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xTDF4dVhHNWpiMjV6ZENCQmMzTmxiV0pzWlhJelJDQTlJSEpsY1hWcGNtVW9KeTR1THk0dUx5NHVMeTR1TDJGemMyVnRZbXhsY2kwelpDY3BPMXh1WTI5dWMzUWdWMlZpWjJ4Q2JXWnZiblJCYzNObGJXSnNaWElnUFNCeVpYRjFhWEpsS0NjdUxpOHlaQzlpYldadmJuUW5LVHRjYmx4dVkyOXVjM1FnZG1Wak15QTlJR05qTG5adFlYUm9MblpsWXpNN1hHNWNibU52Ym5OMElIWmxZek5mZEdWdGNGOXNiMk5oYkNBOUlIWmxZek11WTNKbFlYUmxLQ2s3WEc1amIyNXpkQ0IyWldNelgzUmxiWEJmZDI5eWJHUWdQU0IyWldNekxtTnlaV0YwWlNncE8xeHVYRzVsZUhCdmNuUWdaR1ZtWVhWc2RDQmpiR0Z6Y3lCWFpXSm5iRUp0Wm05dWRFRnpjMlZ0WW14bGNqTkVJR1Y0ZEdWdVpITWdWMlZpWjJ4Q2JXWnZiblJCYzNObGJXSnNaWElnZTF4dVhHNTlYRzVjYm1OakxtcHpMbTFwZUdsdUtGZGxZbWRzUW0xbWIyNTBRWE56WlcxaWJHVnlNMFF1Y0hKdmRHOTBlWEJsTENCQmMzTmxiV0pzWlhJelJDd2dlMXh1SUNBZ0lIVndaR0YwWlZkdmNteGtWbVZ5ZEhNZ0tHTnZiWEFwSUh0Y2JpQWdJQ0FnSUNBZ2JHVjBJRzFoZEhKcGVDQTlJR052YlhBdWJtOWtaUzVmZDI5eWJHUk5ZWFJ5YVhnN1hHNGdJQ0FnSUNBZ0lHeGxkQ0JzYjJOaGJDQTlJSFJvYVhNdVgyeHZZMkZzTzF4dUlDQWdJQ0FnSUNCc1pYUWdkMjl5YkdRZ1BTQjBhR2x6TGw5eVpXNWtaWEpFWVhSaExuWkVZWFJoYzFzd1hUdGNibHh1SUNBZ0lDQWdJQ0JzWlhRZ1pteHZZWFJ6VUdWeVZtVnlkQ0E5SUhSb2FYTXVabXh2WVhSelVHVnlWbVZ5ZER0Y2JpQWdJQ0FnSUNBZ1ptOXlJQ2hzWlhRZ2IyWm1jMlYwSUQwZ01Ec2diMlptYzJWMElEd2dkMjl5YkdRdWJHVnVaM1JvT3lCdlptWnpaWFFnS3owZ1pteHZZWFJ6VUdWeVZtVnlkQ2tnZTF4dUlDQWdJQ0FnSUNBZ0lDQWdkbVZqTXk1elpYUW9kbVZqTTE5MFpXMXdYMnh2WTJGc0xDQnNiMk5oYkZ0dlptWnpaWFJkTENCc2IyTmhiRnR2Wm1aelpYUXJNVjBzSURBcE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZG1Wak15NTBjbUZ1YzJadmNtMU5ZWFEwS0habFl6TmZkR1Z0Y0Y5M2IzSnNaQ3dnZG1Wak0xOTBaVzF3WDJ4dlkyRnNMQ0J0WVhSeWFYZ3BPMXh1WEc0Z0lDQWdJQ0FnSUNBZ0lDQjNiM0pzWkZ0dlptWnpaWFJkSUQwZ2RtVmpNMTkwWlcxd1gzZHZjbXhrTG5nN1hHNGdJQ0FnSUNBZ0lDQWdJQ0IzYjNKc1pGdHZabVp6WlhRck1WMGdQU0IyWldNelgzUmxiWEJmZDI5eWJHUXVlVHRjYmlBZ0lDQWdJQ0FnSUNBZ0lIZHZjbXhrVzI5bVpuTmxkQ3N5WFNBOUlIWmxZek5mZEdWdGNGOTNiM0pzWkM1Nk8xeHVJQ0FnSUNBZ0lDQjlYRzRnSUNBZ2ZWeHVmU2s3WEc0aVhYMD0iXX0=