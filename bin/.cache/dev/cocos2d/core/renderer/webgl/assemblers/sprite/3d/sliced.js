(function () {
    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
    var __module = nodeEnv ? module : { exports: {} };
    var __filename = 'engine-dev/cocos2d/core/renderer/webgl/assemblers/sprite/3d/sliced.js';
    var __require = nodeEnv ? function (request) {
        return require(request);
    } : function (request) {
        return __quick_compile__.require(request, __filename);
    };
    function __define(exports, require, module) {
        if (!nodeEnv) {
            __quick_compile__.registerModule(__filename, module);
        }
                'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function');
            }
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
            }
            return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
                throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Assembler3D = require('../../../../assembler-3d');
        var SlicedAssembler = require('../2d/sliced');
        var vec3 = cc.vmath.vec3;
        var vec3_temp_local = vec3.create();
        var vec3_temp_world = vec3.create();
        var SlicedAssembler3D = function (_SlicedAssembler) {
            _inherits(SlicedAssembler3D, _SlicedAssembler);
            function SlicedAssembler3D() {
                _classCallCheck(this, SlicedAssembler3D);
                return _possibleConstructorReturn(this, (SlicedAssembler3D.__proto__ || Object.getPrototypeOf(SlicedAssembler3D)).apply(this, arguments));
            }
            return SlicedAssembler3D;
        }(SlicedAssembler);
        exports.default = SlicedAssembler3D;
        cc.js.mixin(SlicedAssembler3D.prototype, Assembler3D, {
            updateWorldVerts: function updateWorldVerts(sprite) {
                var matrix = sprite.node._worldMatrix;
                var local = this._local;
                var world = this._renderData.vDatas[0];
                var floatsPerVert = this.floatsPerVert;
                for (var row = 0; row < 4; ++row) {
                    var localRowY = local[row * 2 + 1];
                    for (var col = 0; col < 4; ++col) {
                        var localColX = local[col * 2];
                        vec3.set(vec3_temp_local, localColX, localRowY, 0);
                        vec3.transformMat4(vec3_temp_world, vec3_temp_local, matrix);
                        var worldIndex = (row * 4 + col) * floatsPerVert;
                        world[worldIndex] = vec3_temp_world.x;
                        world[worldIndex + 1] = vec3_temp_world.y;
                        world[worldIndex + 2] = vec3_temp_world.z;
                    }
                }
            }
        });
        module.exports = exports['default'];
    }
    if (nodeEnv) {
        __define(__module.exports, __require, __module);
    } else {
        __quick_compile__.registerModuleFunc(__filename, function () {
            __define(__module.exports, __require, __module);
        });
    }
}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNsaWNlZC5qcyIsIi9Vc2Vycy9TaGFyZWQvYmluZ29fZnJlbnp5L2VuZ2luZS9jb2NvczJkL2NvcmUvcmVuZGVyZXIvd2ViZ2wvYXNzZW1ibGVycy9zcHJpdGUvM2Qvc2xpY2VkLmpzIl0sIm5hbWVzIjpbIkFzc2VtYmxlcjNEIiwicmVxdWlyZSIsIlNsaWNlZEFzc2VtYmxlciIsInZlYzMiLCJjYyIsInZtYXRoIiwidmVjM190ZW1wX2xvY2FsIiwiY3JlYXRlIiwidmVjM190ZW1wX3dvcmxkIiwiU2xpY2VkQXNzZW1ibGVyM0QiLCJqcyIsIm1peGluIiwicHJvdG90eXBlIiwidXBkYXRlV29ybGRWZXJ0cyIsInNwcml0ZSIsIm1hdHJpeCIsIm5vZGUiLCJfd29ybGRNYXRyaXgiLCJsb2NhbCIsIl9sb2NhbCIsIndvcmxkIiwiX3JlbmRlckRhdGEiLCJ2RGF0YXMiLCJmbG9hdHNQZXJWZXJ0Iiwicm93IiwibG9jYWxSb3dZIiwiY29sIiwibG9jYWxDb2xYIiwic2V0IiwidHJhbnNmb3JtTWF0NCIsIndvcmxkSW5kZXgiLCJ4IiwieSIsInoiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBeUJBLElBQU1BLFdBQUFBLEdBQWNDLE9BQUFBLENBQVEsMEJBQVJBLENBQXBCO1FBQ0EsSUFBTUMsZUFBQUEsR0FBa0JELE9BQUFBLENBQVEsY0FBUkEsQ0FBeEI7UUFFQSxJQUFNRSxJQUFBQSxHQUFPQyxFQUFBQSxDQUFHQyxLQUFIRCxDQUFTRCxJQUF0QjtRQUNBLElBQU1HLGVBQUFBLEdBQWtCSCxJQUFBQSxDQUFLSSxNQUFMSixFQUF4QjtRQUNBLElBQU1LLGVBQUFBLEdBQWtCTCxJQUFBQSxDQUFLSSxNQUFMSixFQUF4QjtZQUVxQk0saUJBQUFBOzs7Ozs7O1VBQTBCUDswQkFBMUJPO1FBSXJCTCxFQUFBQSxDQUFHTSxFQUFITixDQUFNTyxLQUFOUCxDQUFZSyxpQkFBQUEsQ0FBa0JHLFNBQTlCUixFQUF5Q0osV0FBekNJLEVBQXNEO0FBQUEsWUFDbERTLGdCQUFBQSxFQURrRCxTQUFBLGdCQUFBLENBQ2hDQyxNQURnQyxFQUN4QjtBQUFBLGdCQUN0QixJQUFJQyxNQUFBQSxHQUFTRCxNQUFBQSxDQUFPRSxJQUFQRixDQUFZRyxZQUF6QixDQURzQjtBQUFBLGdCQUV0QixJQUFJQyxLQUFBQSxHQUFRLEtBQUtDLE1BQWpCLENBRnNCO0FBQUEsZ0JBR3RCLElBQUlDLEtBQUFBLEdBQVEsS0FBS0MsV0FBTCxDQUFpQkMsTUFBakIsQ0FBd0IsQ0FBeEIsQ0FBWixDQUhzQjtBQUFBLGdCQUt0QixJQUFJQyxhQUFBQSxHQUFnQixLQUFLQSxhQUF6QixDQUxzQjtBQUFBLGdCQU10QixLQUFLLElBQUlDLEdBQUFBLEdBQU0sQ0FBVixDQUFMLENBQWtCQSxHQUFBQSxHQUFNLENBQXhCLEVBQTJCLEVBQUVBLEdBQTdCLEVBQWtDO0FBQUEsb0JBQzlCLElBQUlDLFNBQUFBLEdBQVlQLEtBQUFBLENBQU1NLEdBQUFBLEdBQU0sQ0FBTkEsR0FBVSxDQUFoQk4sQ0FBaEIsQ0FEOEI7QUFBQSxvQkFFOUIsS0FBSyxJQUFJUSxHQUFBQSxHQUFNLENBQVYsQ0FBTCxDQUFrQkEsR0FBQUEsR0FBTSxDQUF4QixFQUEyQixFQUFFQSxHQUE3QixFQUFrQztBQUFBLHdCQUM5QixJQUFJQyxTQUFBQSxHQUFZVCxLQUFBQSxDQUFNUSxHQUFBQSxHQUFNLENBQVpSLENBQWhCLENBRDhCO0FBQUEsd0JBRzlCZixJQUFBQSxDQUFLeUIsR0FBTHpCLENBQVNHLGVBQVRILEVBQTBCd0IsU0FBMUJ4QixFQUFxQ3NCLFNBQXJDdEIsRUFBZ0QsQ0FBaERBLEVBSDhCO0FBQUEsd0JBSTlCQSxJQUFBQSxDQUFLMEIsYUFBTDFCLENBQW1CSyxlQUFuQkwsRUFBb0NHLGVBQXBDSCxFQUFxRFksTUFBckRaLEVBSjhCO0FBQUEsd0JBTTlCLElBQUkyQixVQUFBQSxHQUFjTixDQUFBQSxHQUFBQSxHQUFNLENBQU5BLEdBQVVFLEdBQVZGLENBQUQsR0FBa0JELGFBQW5DLENBTjhCO0FBQUEsd0JBTzlCSCxLQUFBQSxDQUFNVSxVQUFOVixJQUFvQlosZUFBQUEsQ0FBZ0J1QixDQUFwQ1gsQ0FQOEI7QUFBQSx3QkFROUJBLEtBQUFBLENBQU1VLFVBQUFBLEdBQVcsQ0FBakJWLElBQXNCWixlQUFBQSxDQUFnQndCLENBQXRDWixDQVI4QjtBQUFBLHdCQVM5QkEsS0FBQUEsQ0FBTVUsVUFBQUEsR0FBVyxDQUFqQlYsSUFBc0JaLGVBQUFBLENBQWdCeUIsQ0FBdENiLENBVDhCO0FBQUEscUJBRko7QUFBQSxpQkFOWjtBQUFBLGFBRHdCO0FBQUEsU0FBdERoQiIsImZpbGUiOiJzbGljZWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLlxuXG4gaHR0cHM6Ly93d3cuY29jb3MuY29tL1xuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxuIHdvcmxkd2lkZSwgcm95YWx0eS1mcmVlLCBub24tYXNzaWduYWJsZSwgcmV2b2NhYmxlIGFuZCBub24tZXhjbHVzaXZlIGxpY2Vuc2VcbiB0byB1c2UgQ29jb3MgQ3JlYXRvciBzb2xlbHkgdG8gZGV2ZWxvcCBnYW1lcyBvbiB5b3VyIHRhcmdldCBwbGF0Zm9ybXMuIFlvdSBzaGFsbFxuIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcbiB1c2VkIGZvciBkZXZlbG9waW5nIGdhbWVzLiBZb3UgYXJlIG5vdCBncmFudGVkIHRvIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXG4gc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIENvY29zIENyZWF0b3IuXG5cbiBUaGUgc29mdHdhcmUgb3IgdG9vbHMgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBhcmUgbGljZW5zZWQsIG5vdCBzb2xkLlxuIFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLiByZXNlcnZlcyBhbGwgcmlnaHRzIG5vdCBleHByZXNzbHkgZ3JhbnRlZCB0byB5b3UuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuIFRIRSBTT0ZUV0FSRS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jb25zdCBBc3NlbWJsZXIzRCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2Fzc2VtYmxlci0zZCcpO1xuY29uc3QgU2xpY2VkQXNzZW1ibGVyID0gcmVxdWlyZSgnLi4vMmQvc2xpY2VkJyk7XG5cbmNvbnN0IHZlYzMgPSBjYy52bWF0aC52ZWMzO1xuY29uc3QgdmVjM190ZW1wX2xvY2FsID0gdmVjMy5jcmVhdGUoKTtcbmNvbnN0IHZlYzNfdGVtcF93b3JsZCA9IHZlYzMuY3JlYXRlKCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNsaWNlZEFzc2VtYmxlcjNEIGV4dGVuZHMgU2xpY2VkQXNzZW1ibGVyIHtcbiAgICBcbn1cblxuY2MuanMubWl4aW4oU2xpY2VkQXNzZW1ibGVyM0QucHJvdG90eXBlLCBBc3NlbWJsZXIzRCwge1xuICAgIHVwZGF0ZVdvcmxkVmVydHMgKHNwcml0ZSkge1xuICAgICAgICBsZXQgbWF0cml4ID0gc3ByaXRlLm5vZGUuX3dvcmxkTWF0cml4O1xuICAgICAgICBsZXQgbG9jYWwgPSB0aGlzLl9sb2NhbDtcbiAgICAgICAgbGV0IHdvcmxkID0gdGhpcy5fcmVuZGVyRGF0YS52RGF0YXNbMF07XG5cbiAgICAgICAgbGV0IGZsb2F0c1BlclZlcnQgPSB0aGlzLmZsb2F0c1BlclZlcnQ7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IDQ7ICsrcm93KSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxSb3dZID0gbG9jYWxbcm93ICogMiArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgNDsgKytjb2wpIHtcbiAgICAgICAgICAgICAgICBsZXQgbG9jYWxDb2xYID0gbG9jYWxbY29sICogMl07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmVjMy5zZXQodmVjM190ZW1wX2xvY2FsLCBsb2NhbENvbFgsIGxvY2FsUm93WSwgMCk7XG4gICAgICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHZlYzNfdGVtcF93b3JsZCwgdmVjM190ZW1wX2xvY2FsLCBtYXRyaXgpO1xuXG4gICAgICAgICAgICAgICAgbGV0IHdvcmxkSW5kZXggPSAocm93ICogNCArIGNvbCkgKiBmbG9hdHNQZXJWZXJ0O1xuICAgICAgICAgICAgICAgIHdvcmxkW3dvcmxkSW5kZXhdID0gdmVjM190ZW1wX3dvcmxkLng7XG4gICAgICAgICAgICAgICAgd29ybGRbd29ybGRJbmRleCsxXSA9IHZlYzNfdGVtcF93b3JsZC55O1xuICAgICAgICAgICAgICAgIHdvcmxkW3dvcmxkSW5kZXgrMl0gPSB2ZWMzX3RlbXBfd29ybGQuejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiBDb3B5cmlnaHQgKGMpIDIwMTctMjAxOCBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC5cblxuIGh0dHBzOi8vd3d3LmNvY29zLmNvbS9cblxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGVuZ2luZSBzb3VyY2UgY29kZSAodGhlIFwiU29mdHdhcmVcIiksIGEgbGltaXRlZCxcbiB3b3JsZHdpZGUsIHJveWFsdHktZnJlZSwgbm9uLWFzc2lnbmFibGUsIHJldm9jYWJsZSBhbmQgbm9uLWV4Y2x1c2l2ZSBsaWNlbnNlXG4gdG8gdXNlIENvY29zIENyZWF0b3Igc29sZWx5IHRvIGRldmVsb3AgZ2FtZXMgb24geW91ciB0YXJnZXQgcGxhdGZvcm1zLiBZb3Ugc2hhbGxcbiBub3QgdXNlIENvY29zIENyZWF0b3Igc29mdHdhcmUgZm9yIGRldmVsb3Bpbmcgb3RoZXIgc29mdHdhcmUgb3IgdG9vbHMgdGhhdCdzXG4gdXNlZCBmb3IgZGV2ZWxvcGluZyBnYW1lcy4gWW91IGFyZSBub3QgZ3JhbnRlZCB0byBwdWJsaXNoLCBkaXN0cmlidXRlLFxuIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiBDb2NvcyBDcmVhdG9yLlxuXG4gVGhlIHNvZnR3YXJlIG9yIHRvb2xzIGluIHRoaXMgTGljZW5zZSBBZ3JlZW1lbnQgYXJlIGxpY2Vuc2VkLCBub3Qgc29sZC5cbiBYaWFtZW4gWWFqaSBTb2Z0d2FyZSBDby4sIEx0ZC4gcmVzZXJ2ZXMgYWxsIHJpZ2h0cyBub3QgZXhwcmVzc2x5IGdyYW50ZWQgdG8geW91LlxuXG4gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiBUSEUgU09GVFdBUkUuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxudmFyIEFzc2VtYmxlcjNEID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vYXNzZW1ibGVyLTNkJyk7XG52YXIgU2xpY2VkQXNzZW1ibGVyID0gcmVxdWlyZSgnLi4vMmQvc2xpY2VkJyk7XG5cbnZhciB2ZWMzID0gY2Mudm1hdGgudmVjMztcbnZhciB2ZWMzX3RlbXBfbG9jYWwgPSB2ZWMzLmNyZWF0ZSgpO1xudmFyIHZlYzNfdGVtcF93b3JsZCA9IHZlYzMuY3JlYXRlKCk7XG5cbnZhciBTbGljZWRBc3NlbWJsZXIzRCA9IGZ1bmN0aW9uIChfU2xpY2VkQXNzZW1ibGVyKSB7XG4gICAgX2luaGVyaXRzKFNsaWNlZEFzc2VtYmxlcjNELCBfU2xpY2VkQXNzZW1ibGVyKTtcblxuICAgIGZ1bmN0aW9uIFNsaWNlZEFzc2VtYmxlcjNEKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpY2VkQXNzZW1ibGVyM0QpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoU2xpY2VkQXNzZW1ibGVyM0QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTbGljZWRBc3NlbWJsZXIzRCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIHJldHVybiBTbGljZWRBc3NlbWJsZXIzRDtcbn0oU2xpY2VkQXNzZW1ibGVyKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU2xpY2VkQXNzZW1ibGVyM0Q7XG5cblxuY2MuanMubWl4aW4oU2xpY2VkQXNzZW1ibGVyM0QucHJvdG90eXBlLCBBc3NlbWJsZXIzRCwge1xuICAgIHVwZGF0ZVdvcmxkVmVydHM6IGZ1bmN0aW9uIHVwZGF0ZVdvcmxkVmVydHMoc3ByaXRlKSB7XG4gICAgICAgIHZhciBtYXRyaXggPSBzcHJpdGUubm9kZS5fd29ybGRNYXRyaXg7XG4gICAgICAgIHZhciBsb2NhbCA9IHRoaXMuX2xvY2FsO1xuICAgICAgICB2YXIgd29ybGQgPSB0aGlzLl9yZW5kZXJEYXRhLnZEYXRhc1swXTtcblxuICAgICAgICB2YXIgZmxvYXRzUGVyVmVydCA9IHRoaXMuZmxvYXRzUGVyVmVydDtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgNDsgKytyb3cpIHtcbiAgICAgICAgICAgIHZhciBsb2NhbFJvd1kgPSBsb2NhbFtyb3cgKiAyICsgMV07XG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCA0OyArK2NvbCkge1xuICAgICAgICAgICAgICAgIHZhciBsb2NhbENvbFggPSBsb2NhbFtjb2wgKiAyXTtcblxuICAgICAgICAgICAgICAgIHZlYzMuc2V0KHZlYzNfdGVtcF9sb2NhbCwgbG9jYWxDb2xYLCBsb2NhbFJvd1ksIDApO1xuICAgICAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NCh2ZWMzX3RlbXBfd29ybGQsIHZlYzNfdGVtcF9sb2NhbCwgbWF0cml4KTtcblxuICAgICAgICAgICAgICAgIHZhciB3b3JsZEluZGV4ID0gKHJvdyAqIDQgKyBjb2wpICogZmxvYXRzUGVyVmVydDtcbiAgICAgICAgICAgICAgICB3b3JsZFt3b3JsZEluZGV4XSA9IHZlYzNfdGVtcF93b3JsZC54O1xuICAgICAgICAgICAgICAgIHdvcmxkW3dvcmxkSW5kZXggKyAxXSA9IHZlYzNfdGVtcF93b3JsZC55O1xuICAgICAgICAgICAgICAgIHdvcmxkW3dvcmxkSW5kZXggKyAyXSA9IHZlYzNfdGVtcF93b3JsZC56O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKemIzVnlZMlZ6SWpwYkluTnNhV05sWkM1cWN5SmRMQ0p1WVcxbGN5STZXeUpCYzNObGJXSnNaWEl6UkNJc0luSmxjWFZwY21VaUxDSlRiR2xqWldSQmMzTmxiV0pzWlhJaUxDSjJaV016SWl3aVkyTWlMQ0oyYldGMGFDSXNJblpsWXpOZmRHVnRjRjlzYjJOaGJDSXNJbU55WldGMFpTSXNJblpsWXpOZmRHVnRjRjkzYjNKc1pDSXNJbE5zYVdObFpFRnpjMlZ0WW14bGNqTkVJaXdpYW5NaUxDSnRhWGhwYmlJc0luQnliM1J2ZEhsd1pTSXNJblZ3WkdGMFpWZHZjbXhrVm1WeWRITWlMQ0p6Y0hKcGRHVWlMQ0p0WVhSeWFYZ2lMQ0p1YjJSbElpd2lYM2R2Y214a1RXRjBjbWw0SWl3aWJHOWpZV3dpTENKZmJHOWpZV3dpTENKM2IzSnNaQ0lzSWw5eVpXNWtaWEpFWVhSaElpd2lka1JoZEdGeklpd2labXh2WVhSelVHVnlWbVZ5ZENJc0luSnZkeUlzSW14dlkyRnNVbTkzV1NJc0ltTnZiQ0lzSW14dlkyRnNRMjlzV0NJc0luTmxkQ0lzSW5SeVlXNXpabTl5YlUxaGREUWlMQ0ozYjNKc1pFbHVaR1Y0SWl3aWVDSXNJbmtpTENKNklsMHNJbTFoY0hCcGJtZHpJam9pT3pzN096czdPenM3T3pzN1FVRkJRVHM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096dEJRWGxDUVN4SlFVRk5RU3hqUVVGalF5eFJRVUZSTERCQ1FVRlNMRU5CUVhCQ08wRkJRMEVzU1VGQlRVTXNhMEpCUVd0Q1JDeFJRVUZSTEdOQlFWSXNRMEZCZUVJN08wRkJSVUVzU1VGQlRVVXNUMEZCVDBNc1IwRkJSME1zUzBGQlNDeERRVUZUUml4SlFVRjBRanRCUVVOQkxFbEJRVTFITEd0Q1FVRnJRa2dzUzBGQlMwa3NUVUZCVEN4RlFVRjRRanRCUVVOQkxFbEJRVTFETEd0Q1FVRnJRa3dzUzBGQlMwa3NUVUZCVEN4RlFVRjRRanM3U1VGRmNVSkZMR2xDT3pzN096czdPenM3TzBWQlFUQkNVQ3hsT3p0clFrRkJNVUpQTEdsQ096czdRVUZKY2tKTUxFZEJRVWROTEVWQlFVZ3NRMEZCVFVNc1MwRkJUaXhEUVVGWlJpeHJRa0ZCYTBKSExGTkJRVGxDTEVWQlFYbERXaXhYUVVGNlF5eEZRVUZ6UkR0QlFVTnNSR0VzYjBKQlJHdEVMRFJDUVVOb1EwTXNUVUZFWjBNc1JVRkRlRUk3UVVGRGRFSXNXVUZCU1VNc1UwRkJVMFFzVDBGQlQwVXNTVUZCVUN4RFFVRlpReXhaUVVGNlFqdEJRVU5CTEZsQlFVbERMRkZCUVZFc1MwRkJTME1zVFVGQmFrSTdRVUZEUVN4WlFVRkpReXhSUVVGUkxFdEJRVXRETEZkQlFVd3NRMEZCYVVKRExFMUJRV3BDTEVOQlFYZENMRU5CUVhoQ0xFTkJRVm83TzBGQlJVRXNXVUZCU1VNc1owSkJRV2RDTEV0QlFVdEJMR0ZCUVhwQ08wRkJRMEVzWVVGQlN5eEpRVUZKUXl4TlFVRk5MRU5CUVdZc1JVRkJhMEpCTEUxQlFVMHNRMEZCZUVJc1JVRkJNa0lzUlVGQlJVRXNSMEZCTjBJc1JVRkJhME03UVVGRE9VSXNaMEpCUVVsRExGbEJRVmxRTEUxQlFVMU5MRTFCUVUwc1EwRkJUaXhIUVVGVkxFTkJRV2hDTEVOQlFXaENPMEZCUTBFc2FVSkJRVXNzU1VGQlNVVXNUVUZCVFN4RFFVRm1MRVZCUVd0Q1FTeE5RVUZOTEVOQlFYaENMRVZCUVRKQ0xFVkJRVVZCTEVkQlFUZENMRVZCUVd0RE8wRkJRemxDTEc5Q1FVRkpReXhaUVVGWlZDeE5RVUZOVVN4TlFVRk5MRU5CUVZvc1EwRkJhRUk3TzBGQlJVRjJRaXh4UWtGQlMzbENMRWRCUVV3c1EwRkJVM1JDTEdWQlFWUXNSVUZCTUVKeFFpeFRRVUV4UWl4RlFVRnhRMFlzVTBGQmNrTXNSVUZCWjBRc1EwRkJhRVE3UVVGRFFYUkNMSEZDUVVGTE1FSXNZVUZCVEN4RFFVRnRRbkpDTEdWQlFXNUNMRVZCUVc5RFJpeGxRVUZ3UXl4RlFVRnhSRk1zVFVGQmNrUTdPMEZCUlVFc2IwSkJRVWxsTEdGQlFXRXNRMEZCUTA0c1RVRkJUU3hEUVVGT0xFZEJRVlZGTEVkQlFWZ3NTVUZCYTBKSUxHRkJRVzVETzBGQlEwRklMSE5DUVVGTlZTeFZRVUZPTEVsQlFXOUNkRUlzWjBKQlFXZENkVUlzUTBGQmNFTTdRVUZEUVZnc2MwSkJRVTFWTEdGQlFWY3NRMEZCYWtJc1NVRkJjMEowUWl4blFrRkJaMEozUWl4RFFVRjBRenRCUVVOQldpeHpRa0ZCVFZVc1lVRkJWeXhEUVVGcVFpeEpRVUZ6UW5SQ0xHZENRVUZuUW5sQ0xFTkJRWFJETzBGQlEwZzdRVUZEU2p0QlFVTktPMEZCY2tKcFJDeERRVUYwUkNJc0ltWnBiR1VpT2lKemJHbGpaV1F1YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2x4dUlFTnZjSGx5YVdkb2RDQW9ZeWtnTWpBeE55MHlNREU0SUZocFlXMWxiaUJaWVdwcElGTnZablIzWVhKbElFTnZMaXdnVEhSa0xseHVYRzRnYUhSMGNITTZMeTkzZDNjdVkyOWpiM011WTI5dEwxeHVYRzRnVUdWeWJXbHpjMmx2YmlCcGN5Qm9aWEpsWW5rZ1ozSmhiblJsWkN3Z1puSmxaU0J2WmlCamFHRnlaMlVzSUhSdklHRnVlU0J3WlhKemIyNGdiMkowWVdsdWFXNW5JR0VnWTI5d2VWeHVJRzltSUhSb2FYTWdjMjltZEhkaGNtVWdZVzVrSUdGemMyOWphV0YwWldRZ1pXNW5hVzVsSUhOdmRYSmpaU0JqYjJSbElDaDBhR1VnWENKVGIyWjBkMkZ5WlZ3aUtTd2dZU0JzYVcxcGRHVmtMRnh1SUhkdmNteGtkMmxrWlN3Z2NtOTVZV3gwZVMxbWNtVmxMQ0J1YjI0dFlYTnphV2R1WVdKc1pTd2djbVYyYjJOaFlteGxJR0Z1WkNCdWIyNHRaWGhqYkhWemFYWmxJR3hwWTJWdWMyVmNiaUIwYnlCMWMyVWdRMjlqYjNNZ1EzSmxZWFJ2Y2lCemIyeGxiSGtnZEc4Z1pHVjJaV3h2Y0NCbllXMWxjeUJ2YmlCNWIzVnlJSFJoY21kbGRDQndiR0YwWm05eWJYTXVJRmx2ZFNCemFHRnNiRnh1SUc1dmRDQjFjMlVnUTI5amIzTWdRM0psWVhSdmNpQnpiMlowZDJGeVpTQm1iM0lnWkdWMlpXeHZjR2x1WnlCdmRHaGxjaUJ6YjJaMGQyRnlaU0J2Y2lCMGIyOXNjeUIwYUdGMEozTmNiaUIxYzJWa0lHWnZjaUJrWlhabGJHOXdhVzVuSUdkaGJXVnpMaUJaYjNVZ1lYSmxJRzV2ZENCbmNtRnVkR1ZrSUhSdklIQjFZbXhwYzJnc0lHUnBjM1J5YVdKMWRHVXNYRzRnYzNWaWJHbGpaVzV6WlN3Z1lXNWtMMjl5SUhObGJHd2dZMjl3YVdWeklHOW1JRU52WTI5eklFTnlaV0YwYjNJdVhHNWNiaUJVYUdVZ2MyOW1kSGRoY21VZ2IzSWdkRzl2YkhNZ2FXNGdkR2hwY3lCTWFXTmxibk5sSUVGbmNtVmxiV1Z1ZENCaGNtVWdiR2xqWlc1elpXUXNJRzV2ZENCemIyeGtMbHh1SUZocFlXMWxiaUJaWVdwcElGTnZablIzWVhKbElFTnZMaXdnVEhSa0xpQnlaWE5sY25abGN5QmhiR3dnY21sbmFIUnpJRzV2ZENCbGVIQnlaWE56YkhrZ1ozSmhiblJsWkNCMGJ5QjViM1V1WEc1Y2JpQlVTRVVnVTA5R1ZGZEJVa1VnU1ZNZ1VGSlBWa2xFUlVRZ1hDSkJVeUJKVTF3aUxDQlhTVlJJVDFWVUlGZEJVbEpCVGxSWklFOUdJRUZPV1NCTFNVNUVMQ0JGV0ZCU1JWTlRJRTlTWEc0Z1NVMVFURWxGUkN3Z1NVNURURlZFU1U1SElFSlZWQ0JPVDFRZ1RFbE5TVlJGUkNCVVR5QlVTRVVnVjBGU1VrRk9WRWxGVXlCUFJpQk5SVkpEU0VGT1ZFRkNTVXhKVkZrc1hHNGdSa2xVVGtWVFV5QkdUMUlnUVNCUVFWSlVTVU5WVEVGU0lGQlZVbEJQVTBVZ1FVNUVJRTVQVGtsT1JsSkpUa2RGVFVWT1ZDNGdTVTRnVGs4Z1JWWkZUbFFnVTBoQlRFd2dWRWhGWEc0Z1FWVlVTRTlTVXlCUFVpQkRUMUJaVWtsSFNGUWdTRTlNUkVWU1V5QkNSU0JNU1VGQ1RFVWdSazlTSUVGT1dTQkRURUZKVFN3Z1JFRk5RVWRGVXlCUFVpQlBWRWhGVWx4dUlFeEpRVUpKVEVsVVdTd2dWMGhGVkVoRlVpQkpUaUJCVGlCQlExUkpUMDRnVDBZZ1EwOU9WRkpCUTFRc0lGUlBVbFFnVDFJZ1QxUklSVkpYU1ZORkxDQkJVa2xUU1U1SElFWlNUMDBzWEc0Z1QxVlVJRTlHSUU5U0lFbE9JRU5QVGs1RlExUkpUMDRnVjBsVVNDQlVTRVVnVTA5R1ZGZEJVa1VnVDFJZ1ZFaEZJRlZUUlNCUFVpQlBWRWhGVWlCRVJVRk1TVTVIVXlCSlRseHVJRlJJUlNCVFQwWlVWMEZTUlM1Y2JpQXFLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xTDF4dVhHNWpiMjV6ZENCQmMzTmxiV0pzWlhJelJDQTlJSEpsY1hWcGNtVW9KeTR1THk0dUx5NHVMeTR1TDJGemMyVnRZbXhsY2kwelpDY3BPMXh1WTI5dWMzUWdVMnhwWTJWa1FYTnpaVzFpYkdWeUlEMGdjbVZ4ZFdseVpTZ25MaTR2TW1RdmMyeHBZMlZrSnlrN1hHNWNibU52Ym5OMElIWmxZek1nUFNCall5NTJiV0YwYUM1MlpXTXpPMXh1WTI5dWMzUWdkbVZqTTE5MFpXMXdYMnh2WTJGc0lEMGdkbVZqTXk1amNtVmhkR1VvS1R0Y2JtTnZibk4wSUhabFl6TmZkR1Z0Y0Y5M2IzSnNaQ0E5SUhabFl6TXVZM0psWVhSbEtDazdYRzVjYm1WNGNHOXlkQ0JrWldaaGRXeDBJR05zWVhOeklGTnNhV05sWkVGemMyVnRZbXhsY2pORUlHVjRkR1Z1WkhNZ1UyeHBZMlZrUVhOelpXMWliR1Z5SUh0Y2JpQWdJQ0JjYm4xY2JseHVZMk11YW5NdWJXbDRhVzRvVTJ4cFkyVmtRWE56WlcxaWJHVnlNMFF1Y0hKdmRHOTBlWEJsTENCQmMzTmxiV0pzWlhJelJDd2dlMXh1SUNBZ0lIVndaR0YwWlZkdmNteGtWbVZ5ZEhNZ0tITndjbWwwWlNrZ2UxeHVJQ0FnSUNBZ0lDQnNaWFFnYldGMGNtbDRJRDBnYzNCeWFYUmxMbTV2WkdVdVgzZHZjbXhrVFdGMGNtbDRPMXh1SUNBZ0lDQWdJQ0JzWlhRZ2JHOWpZV3dnUFNCMGFHbHpMbDlzYjJOaGJEdGNiaUFnSUNBZ0lDQWdiR1YwSUhkdmNteGtJRDBnZEdocGN5NWZjbVZ1WkdWeVJHRjBZUzUyUkdGMFlYTmJNRjA3WEc1Y2JpQWdJQ0FnSUNBZ2JHVjBJR1pzYjJGMGMxQmxjbFpsY25RZ1BTQjBhR2x6TG1ac2IyRjBjMUJsY2xabGNuUTdYRzRnSUNBZ0lDQWdJR1p2Y2lBb2JHVjBJSEp2ZHlBOUlEQTdJSEp2ZHlBOElEUTdJQ3NyY205M0tTQjdYRzRnSUNBZ0lDQWdJQ0FnSUNCc1pYUWdiRzlqWVd4U2IzZFpJRDBnYkc5allXeGJjbTkzSUNvZ01pQXJJREZkTzF4dUlDQWdJQ0FnSUNBZ0lDQWdabTl5SUNoc1pYUWdZMjlzSUQwZ01Ec2dZMjlzSUR3Z05Ec2dLeXRqYjJ3cElIdGNiaUFnSUNBZ0lDQWdJQ0FnSUNBZ0lDQnNaWFFnYkc5allXeERiMnhZSUQwZ2JHOWpZV3hiWTI5c0lDb2dNbDA3WEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnWEc0Z0lDQWdJQ0FnSUNBZ0lDQWdJQ0FnZG1Wak15NXpaWFFvZG1Wak0xOTBaVzF3WDJ4dlkyRnNMQ0JzYjJOaGJFTnZiRmdzSUd4dlkyRnNVbTkzV1N3Z01DazdYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdkbVZqTXk1MGNtRnVjMlp2Y20xTllYUTBLSFpsWXpOZmRHVnRjRjkzYjNKc1pDd2dkbVZqTTE5MFpXMXdYMnh2WTJGc0xDQnRZWFJ5YVhncE8xeHVYRzRnSUNBZ0lDQWdJQ0FnSUNBZ0lDQWdiR1YwSUhkdmNteGtTVzVrWlhnZ1BTQW9jbTkzSUNvZ05DQXJJR052YkNrZ0tpQm1iRzloZEhOUVpYSldaWEowTzF4dUlDQWdJQ0FnSUNBZ0lDQWdJQ0FnSUhkdmNteGtXM2R2Y214a1NXNWtaWGhkSUQwZ2RtVmpNMTkwWlcxd1gzZHZjbXhrTG5nN1hHNGdJQ0FnSUNBZ0lDQWdJQ0FnSUNBZ2QyOXliR1JiZDI5eWJHUkpibVJsZUNzeFhTQTlJSFpsWXpOZmRHVnRjRjkzYjNKc1pDNTVPMXh1SUNBZ0lDQWdJQ0FnSUNBZ0lDQWdJSGR2Y214a1czZHZjbXhrU1c1a1pYZ3JNbDBnUFNCMlpXTXpYM1JsYlhCZmQyOXliR1F1ZWp0Y2JpQWdJQ0FnSUNBZ0lDQWdJSDFjYmlBZ0lDQWdJQ0FnZlZ4dUlDQWdJSDFjYm4wcE8xeHVJbDE5Il19