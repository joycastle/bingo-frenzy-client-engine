(function () {
    var nodeEnv = typeof require !== 'undefined' && typeof process !== 'undefined';
    var __module = nodeEnv ? module : { exports: {} };
    var __filename = 'engine-dev/cocos2d/core/renderer/webgl/assemblers/label/3d/outline-bmfont.js';
    var __require = nodeEnv ? function (request) {
        return require(request);
    } : function (request) {
        return __quick_compile__.require(request, __filename);
    };
    function __define(exports, require, module) {
        if (!nodeEnv) {
            __quick_compile__.registerModule(__filename, module);
        }
                'use strict';
        Object.defineProperty(exports, '__esModule', { value: true });
        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError('Cannot call a class as a function');
            }
        }
        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError('this hasn\'t been initialised - super() hasn\'t been called');
            }
            return call && (typeof call === 'object' || typeof call === 'function') ? call : self;
        }
        function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
                throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass)
                Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }
        var Assembler3D = require('../../../../assembler-3d');
        var WebglColorBmfontAssembler = require('../2d/outline-bmfont');
        var vec3 = cc.vmath.vec3;
        var vec3_temp_local = vec3.create();
        var vec3_temp_world = vec3.create();
        var WebglColorBmfontAssembler3D = function (_WebglColorBmfontAsse) {
            _inherits(WebglColorBmfontAssembler3D, _WebglColorBmfontAsse);
            function WebglColorBmfontAssembler3D() {
                _classCallCheck(this, WebglColorBmfontAssembler3D);
                return _possibleConstructorReturn(this, (WebglColorBmfontAssembler3D.__proto__ || Object.getPrototypeOf(WebglColorBmfontAssembler3D)).apply(this, arguments));
            }
            return WebglColorBmfontAssembler3D;
        }(WebglColorBmfontAssembler);
        exports.default = WebglColorBmfontAssembler3D;
        cc.js.mixin(WebglColorBmfontAssembler3D.prototype, Assembler3D, {
            updateWorldVerts: function updateWorldVerts(comp) {
                var matrix = comp.node._worldMatrix;
                var local = this._local;
                var world = this._renderData.vDatas[0];
                var floatsPerVert = this.floatsPerVert;
                for (var offset = 0; offset < world.length; offset += floatsPerVert) {
                    vec3.set(vec3_temp_local, local[offset], local[offset + 1], 0);
                    vec3.transformMat4(vec3_temp_world, vec3_temp_local, matrix);
                    world[offset] = vec3_temp_world.x;
                    world[offset + 1] = vec3_temp_world.y;
                    world[offset + 2] = vec3_temp_world.z;
                }
            }
        });
        module.exports = exports['default'];
    }
    if (nodeEnv) {
        __define(__module.exports, __require, __module);
    } else {
        __quick_compile__.registerModuleFunc(__filename, function () {
            __define(__module.exports, __require, __module);
        });
    }
}());
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm91dGxpbmUtYm1mb250LmpzIiwiL1VzZXJzL2dhb3lhbmcvV29ya1NwYWNlL2pveWNhc3RsZS9iaW5nby9jbGllbnQvYmluZ28vZW5naW5lL2NvY29zMmQvY29yZS9yZW5kZXJlci93ZWJnbC9hc3NlbWJsZXJzL2xhYmVsLzNkL291dGxpbmUtYm1mb250LmpzIl0sIm5hbWVzIjpbIkFzc2VtYmxlcjNEIiwicmVxdWlyZSIsIldlYmdsQ29sb3JCbWZvbnRBc3NlbWJsZXIiLCJ2ZWMzIiwiY2MiLCJ2bWF0aCIsInZlYzNfdGVtcF9sb2NhbCIsImNyZWF0ZSIsInZlYzNfdGVtcF93b3JsZCIsIldlYmdsQ29sb3JCbWZvbnRBc3NlbWJsZXIzRCIsImpzIiwibWl4aW4iLCJwcm90b3R5cGUiLCJ1cGRhdGVXb3JsZFZlcnRzIiwiY29tcCIsIm1hdHJpeCIsIm5vZGUiLCJfd29ybGRNYXRyaXgiLCJsb2NhbCIsIl9sb2NhbCIsIndvcmxkIiwiX3JlbmRlckRhdGEiLCJ2RGF0YXMiLCJmbG9hdHNQZXJWZXJ0Iiwib2Zmc2V0IiwibGVuZ3RoIiwic2V0IiwidHJhbnNmb3JtTWF0NCIsIngiLCJ5IiwieiJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7UUF5QkEsSUFBTUEsV0FBQUEsR0FBY0MsT0FBQUEsQ0FBUSwwQkFBUkEsQ0FBcEI7UUFDQSxJQUFNQyx5QkFBQUEsR0FBNEJELE9BQUFBLENBQVEsc0JBQVJBLENBQWxDO1FBRUEsSUFBTUUsSUFBQUEsR0FBT0MsRUFBQUEsQ0FBR0MsS0FBSEQsQ0FBU0QsSUFBdEI7UUFFQSxJQUFNRyxlQUFBQSxHQUFrQkgsSUFBQUEsQ0FBS0ksTUFBTEosRUFBeEI7UUFDQSxJQUFNSyxlQUFBQSxHQUFrQkwsSUFBQUEsQ0FBS0ksTUFBTEosRUFBeEI7WUFFcUJNLDJCQUFBQTs7Ozs7OztVQUFvQ1A7MEJBQXBDTztRQUlyQkwsRUFBQUEsQ0FBR00sRUFBSE4sQ0FBTU8sS0FBTlAsQ0FBWUssMkJBQUFBLENBQTRCRyxTQUF4Q1IsRUFBbURKLFdBQW5ESSxFQUFnRTtBQUFBLFlBQzVEUyxnQkFBQUEsRUFENEQsU0FBQSxnQkFBQSxDQUMxQ0MsSUFEMEMsRUFDcEM7QUFBQSxnQkFDcEIsSUFBSUMsTUFBQUEsR0FBU0QsSUFBQUEsQ0FBS0UsSUFBTEYsQ0FBVUcsWUFBdkIsQ0FEb0I7QUFBQSxnQkFFcEIsSUFBSUMsS0FBQUEsR0FBUSxLQUFLQyxNQUFqQixDQUZvQjtBQUFBLGdCQUdwQixJQUFJQyxLQUFBQSxHQUFRLEtBQUtDLFdBQUwsQ0FBaUJDLE1BQWpCLENBQXdCLENBQXhCLENBQVosQ0FIb0I7QUFBQSxnQkFLcEIsSUFBSUMsYUFBQUEsR0FBZ0IsS0FBS0EsYUFBekIsQ0FMb0I7QUFBQSxnQkFNcEIsS0FBSyxJQUFJQyxNQUFBQSxHQUFTLENBQWIsQ0FBTCxDQUFxQkEsTUFBQUEsR0FBU0osS0FBQUEsQ0FBTUssTUFBcEMsRUFBNENELE1BQUFBLElBQVVELGFBQXRELEVBQXFFO0FBQUEsb0JBQ2pFcEIsSUFBQUEsQ0FBS3VCLEdBQUx2QixDQUFTRyxlQUFUSCxFQUEwQmUsS0FBQUEsQ0FBTU0sTUFBTk4sQ0FBMUJmLEVBQXlDZSxLQUFBQSxDQUFNTSxNQUFBQSxHQUFPLENBQWJOLENBQXpDZixFQUEwRCxDQUExREEsRUFEaUU7QUFBQSxvQkFFakVBLElBQUFBLENBQUt3QixhQUFMeEIsQ0FBbUJLLGVBQW5CTCxFQUFvQ0csZUFBcENILEVBQXFEWSxNQUFyRFosRUFGaUU7QUFBQSxvQkFJakVpQixLQUFBQSxDQUFNSSxNQUFOSixJQUFnQlosZUFBQUEsQ0FBZ0JvQixDQUFoQ1IsQ0FKaUU7QUFBQSxvQkFLakVBLEtBQUFBLENBQU1JLE1BQUFBLEdBQU8sQ0FBYkosSUFBa0JaLGVBQUFBLENBQWdCcUIsQ0FBbENULENBTGlFO0FBQUEsb0JBTWpFQSxLQUFBQSxDQUFNSSxNQUFBQSxHQUFPLENBQWJKLElBQWtCWixlQUFBQSxDQUFnQnNCLENBQWxDVixDQU5pRTtBQUFBLGlCQU5qRDtBQUFBLGFBRG9DO0FBQUEsU0FBaEVoQiIsImZpbGUiOiJvdXRsaW5lLWJtZm9udC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gQ29weXJpZ2h0IChjKSAyMDE3LTIwMTggWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuXG5cbiBodHRwczovL3d3dy5jb2Nvcy5jb20vXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBlbmdpbmUgc291cmNlIGNvZGUgKHRoZSBcIlNvZnR3YXJlXCIpLCBhIGxpbWl0ZWQsXG4gd29ybGR3aWRlLCByb3lhbHR5LWZyZWUsIG5vbi1hc3NpZ25hYmxlLCByZXZvY2FibGUgYW5kIG5vbi1leGNsdXNpdmUgbGljZW5zZVxuIHRvIHVzZSBDb2NvcyBDcmVhdG9yIHNvbGVseSB0byBkZXZlbG9wIGdhbWVzIG9uIHlvdXIgdGFyZ2V0IHBsYXRmb3Jtcy4gWW91IHNoYWxsXG4gbm90IHVzZSBDb2NvcyBDcmVhdG9yIHNvZnR3YXJlIGZvciBkZXZlbG9waW5nIG90aGVyIHNvZnR3YXJlIG9yIHRvb2xzIHRoYXQnc1xuIHVzZWQgZm9yIGRldmVsb3BpbmcgZ2FtZXMuIFlvdSBhcmUgbm90IGdyYW50ZWQgdG8gcHVibGlzaCwgZGlzdHJpYnV0ZSxcbiBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgQ29jb3MgQ3JlYXRvci5cblxuIFRoZSBzb2Z0d2FyZSBvciB0b29scyBpbiB0aGlzIExpY2Vuc2UgQWdyZWVtZW50IGFyZSBsaWNlbnNlZCwgbm90IHNvbGQuXG4gWGlhbWVuIFlhamkgU29mdHdhcmUgQ28uLCBMdGQuIHJlc2VydmVzIGFsbCByaWdodHMgbm90IGV4cHJlc3NseSBncmFudGVkIHRvIHlvdS5cblxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gVEhFIFNPRlRXQVJFLlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmNvbnN0IEFzc2VtYmxlcjNEID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vYXNzZW1ibGVyLTNkJyk7XG5jb25zdCBXZWJnbENvbG9yQm1mb250QXNzZW1ibGVyID0gcmVxdWlyZSgnLi4vMmQvb3V0bGluZS1ibWZvbnQnKTtcblxuY29uc3QgdmVjMyA9IGNjLnZtYXRoLnZlYzM7XG5cbmNvbnN0IHZlYzNfdGVtcF9sb2NhbCA9IHZlYzMuY3JlYXRlKCk7XG5jb25zdCB2ZWMzX3RlbXBfd29ybGQgPSB2ZWMzLmNyZWF0ZSgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJnbENvbG9yQm1mb250QXNzZW1ibGVyM0QgZXh0ZW5kcyBXZWJnbENvbG9yQm1mb250QXNzZW1ibGVyIHtcblxufVxuXG5jYy5qcy5taXhpbihXZWJnbENvbG9yQm1mb250QXNzZW1ibGVyM0QucHJvdG90eXBlLCBBc3NlbWJsZXIzRCwge1xuICAgIHVwZGF0ZVdvcmxkVmVydHMgKGNvbXApIHtcbiAgICAgICAgbGV0IG1hdHJpeCA9IGNvbXAubm9kZS5fd29ybGRNYXRyaXg7XG4gICAgICAgIGxldCBsb2NhbCA9IHRoaXMuX2xvY2FsO1xuICAgICAgICBsZXQgd29ybGQgPSB0aGlzLl9yZW5kZXJEYXRhLnZEYXRhc1swXTtcblxuICAgICAgICBsZXQgZmxvYXRzUGVyVmVydCA9IHRoaXMuZmxvYXRzUGVyVmVydDtcbiAgICAgICAgZm9yIChsZXQgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgd29ybGQubGVuZ3RoOyBvZmZzZXQgKz0gZmxvYXRzUGVyVmVydCkge1xuICAgICAgICAgICAgdmVjMy5zZXQodmVjM190ZW1wX2xvY2FsLCBsb2NhbFtvZmZzZXRdLCBsb2NhbFtvZmZzZXQrMV0sIDApO1xuICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHZlYzNfdGVtcF93b3JsZCwgdmVjM190ZW1wX2xvY2FsLCBtYXRyaXgpO1xuXG4gICAgICAgICAgICB3b3JsZFtvZmZzZXRdID0gdmVjM190ZW1wX3dvcmxkLng7XG4gICAgICAgICAgICB3b3JsZFtvZmZzZXQrMV0gPSB2ZWMzX3RlbXBfd29ybGQueTtcbiAgICAgICAgICAgIHdvcmxkW29mZnNldCsyXSA9IHZlYzNfdGVtcF93b3JsZC56O1xuICAgICAgICB9XG4gICAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuIENvcHlyaWdodCAoYykgMjAxNy0yMDE4IFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLlxuXG4gaHR0cHM6Ly93d3cuY29jb3MuY29tL1xuXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZW5naW5lIHNvdXJjZSBjb2RlICh0aGUgXCJTb2Z0d2FyZVwiKSwgYSBsaW1pdGVkLFxuIHdvcmxkd2lkZSwgcm95YWx0eS1mcmVlLCBub24tYXNzaWduYWJsZSwgcmV2b2NhYmxlIGFuZCBub24tZXhjbHVzaXZlIGxpY2Vuc2VcbiB0byB1c2UgQ29jb3MgQ3JlYXRvciBzb2xlbHkgdG8gZGV2ZWxvcCBnYW1lcyBvbiB5b3VyIHRhcmdldCBwbGF0Zm9ybXMuIFlvdSBzaGFsbFxuIG5vdCB1c2UgQ29jb3MgQ3JlYXRvciBzb2Z0d2FyZSBmb3IgZGV2ZWxvcGluZyBvdGhlciBzb2Z0d2FyZSBvciB0b29scyB0aGF0J3NcbiB1c2VkIGZvciBkZXZlbG9waW5nIGdhbWVzLiBZb3UgYXJlIG5vdCBncmFudGVkIHRvIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsXG4gc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIENvY29zIENyZWF0b3IuXG5cbiBUaGUgc29mdHdhcmUgb3IgdG9vbHMgaW4gdGhpcyBMaWNlbnNlIEFncmVlbWVudCBhcmUgbGljZW5zZWQsIG5vdCBzb2xkLlxuIFhpYW1lbiBZYWppIFNvZnR3YXJlIENvLiwgTHRkLiByZXNlcnZlcyBhbGwgcmlnaHRzIG5vdCBleHByZXNzbHkgZ3JhbnRlZCB0byB5b3UuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuIFRIRSBTT0ZUV0FSRS5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG52YXIgQXNzZW1ibGVyM0QgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9hc3NlbWJsZXItM2QnKTtcbnZhciBXZWJnbENvbG9yQm1mb250QXNzZW1ibGVyID0gcmVxdWlyZSgnLi4vMmQvb3V0bGluZS1ibWZvbnQnKTtcblxudmFyIHZlYzMgPSBjYy52bWF0aC52ZWMzO1xuXG52YXIgdmVjM190ZW1wX2xvY2FsID0gdmVjMy5jcmVhdGUoKTtcbnZhciB2ZWMzX3RlbXBfd29ybGQgPSB2ZWMzLmNyZWF0ZSgpO1xuXG52YXIgV2ViZ2xDb2xvckJtZm9udEFzc2VtYmxlcjNEID0gZnVuY3Rpb24gKF9XZWJnbENvbG9yQm1mb250QXNzZSkge1xuICAgIF9pbmhlcml0cyhXZWJnbENvbG9yQm1mb250QXNzZW1ibGVyM0QsIF9XZWJnbENvbG9yQm1mb250QXNzZSk7XG5cbiAgICBmdW5jdGlvbiBXZWJnbENvbG9yQm1mb250QXNzZW1ibGVyM0QoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJnbENvbG9yQm1mb250QXNzZW1ibGVyM0QpO1xuXG4gICAgICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoV2ViZ2xDb2xvckJtZm9udEFzc2VtYmxlcjNELl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoV2ViZ2xDb2xvckJtZm9udEFzc2VtYmxlcjNEKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdlYmdsQ29sb3JCbWZvbnRBc3NlbWJsZXIzRDtcbn0oV2ViZ2xDb2xvckJtZm9udEFzc2VtYmxlcik7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFdlYmdsQ29sb3JCbWZvbnRBc3NlbWJsZXIzRDtcblxuXG5jYy5qcy5taXhpbihXZWJnbENvbG9yQm1mb250QXNzZW1ibGVyM0QucHJvdG90eXBlLCBBc3NlbWJsZXIzRCwge1xuICAgIHVwZGF0ZVdvcmxkVmVydHM6IGZ1bmN0aW9uIHVwZGF0ZVdvcmxkVmVydHMoY29tcCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gY29tcC5ub2RlLl93b3JsZE1hdHJpeDtcbiAgICAgICAgdmFyIGxvY2FsID0gdGhpcy5fbG9jYWw7XG4gICAgICAgIHZhciB3b3JsZCA9IHRoaXMuX3JlbmRlckRhdGEudkRhdGFzWzBdO1xuXG4gICAgICAgIHZhciBmbG9hdHNQZXJWZXJ0ID0gdGhpcy5mbG9hdHNQZXJWZXJ0O1xuICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCB3b3JsZC5sZW5ndGg7IG9mZnNldCArPSBmbG9hdHNQZXJWZXJ0KSB7XG4gICAgICAgICAgICB2ZWMzLnNldCh2ZWMzX3RlbXBfbG9jYWwsIGxvY2FsW29mZnNldF0sIGxvY2FsW29mZnNldCArIDFdLCAwKTtcbiAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NCh2ZWMzX3RlbXBfd29ybGQsIHZlYzNfdGVtcF9sb2NhbCwgbWF0cml4KTtcblxuICAgICAgICAgICAgd29ybGRbb2Zmc2V0XSA9IHZlYzNfdGVtcF93b3JsZC54O1xuICAgICAgICAgICAgd29ybGRbb2Zmc2V0ICsgMV0gPSB2ZWMzX3RlbXBfd29ybGQueTtcbiAgICAgICAgICAgIHdvcmxkW29mZnNldCArIDJdID0gdmVjM190ZW1wX3dvcmxkLno7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LGV5SjJaWEp6YVc5dUlqb3pMQ0p6YjNWeVkyVnpJanBiSW05MWRHeHBibVV0WW0xbWIyNTBMbXB6SWwwc0ltNWhiV1Z6SWpwYklrRnpjMlZ0WW14bGNqTkVJaXdpY21WeGRXbHlaU0lzSWxkbFltZHNRMjlzYjNKQ2JXWnZiblJCYzNObGJXSnNaWElpTENKMlpXTXpJaXdpWTJNaUxDSjJiV0YwYUNJc0luWmxZek5mZEdWdGNGOXNiMk5oYkNJc0ltTnlaV0YwWlNJc0luWmxZek5mZEdWdGNGOTNiM0pzWkNJc0lsZGxZbWRzUTI5c2IzSkNiV1p2Ym5SQmMzTmxiV0pzWlhJelJDSXNJbXB6SWl3aWJXbDRhVzRpTENKd2NtOTBiM1I1Y0dVaUxDSjFjR1JoZEdWWGIzSnNaRlpsY25Seklpd2lZMjl0Y0NJc0ltMWhkSEpwZUNJc0ltNXZaR1VpTENKZmQyOXliR1JOWVhSeWFYZ2lMQ0pzYjJOaGJDSXNJbDlzYjJOaGJDSXNJbmR2Y214a0lpd2lYM0psYm1SbGNrUmhkR0VpTENKMlJHRjBZWE1pTENKbWJHOWhkSE5RWlhKV1pYSjBJaXdpYjJabWMyVjBJaXdpYkdWdVozUm9JaXdpYzJWMElpd2lkSEpoYm5ObWIzSnRUV0YwTkNJc0luZ2lMQ0o1SWl3aWVpSmRMQ0p0WVhCd2FXNW5jeUk2SWpzN096czdPenM3T3pzN08wRkJRVUU3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdRVUY1UWtFc1NVRkJUVUVzWTBGQlkwTXNVVUZCVVN3d1FrRkJVaXhEUVVGd1FqdEJRVU5CTEVsQlFVMURMRFJDUVVFMFFrUXNVVUZCVVN4elFrRkJVaXhEUVVGc1F6czdRVUZGUVN4SlFVRk5SU3hQUVVGUFF5eEhRVUZIUXl4TFFVRklMRU5CUVZOR0xFbEJRWFJDT3p0QlFVVkJMRWxCUVUxSExHdENRVUZyUWtnc1MwRkJTMGtzVFVGQlRDeEZRVUY0UWp0QlFVTkJMRWxCUVUxRExHdENRVUZyUWt3c1MwRkJTMGtzVFVGQlRDeEZRVUY0UWpzN1NVRkZjVUpGTERKQ096czdPenM3T3pzN08wVkJRVzlEVUN4NVFqczdhMEpCUVhCRFR5d3lRanM3TzBGQlNYSkNUQ3hIUVVGSFRTeEZRVUZJTEVOQlFVMURMRXRCUVU0c1EwRkJXVVlzTkVKQlFUUkNSeXhUUVVGNFF5eEZRVUZ0UkZvc1YwRkJia1FzUlVGQlowVTdRVUZETlVSaExHOUNRVVEwUkN3MFFrRkRNVU5ETEVsQlJEQkRMRVZCUTNCRE8wRkJRM0JDTEZsQlFVbERMRk5CUVZORUxFdEJRVXRGTEVsQlFVd3NRMEZCVlVNc1dVRkJka0k3UVVGRFFTeFpRVUZKUXl4UlFVRlJMRXRCUVV0RExFMUJRV3BDTzBGQlEwRXNXVUZCU1VNc1VVRkJVU3hMUVVGTFF5eFhRVUZNTEVOQlFXbENReXhOUVVGcVFpeERRVUYzUWl4RFFVRjRRaXhEUVVGYU96dEJRVVZCTEZsQlFVbERMR2RDUVVGblFpeExRVUZMUVN4aFFVRjZRanRCUVVOQkxHRkJRVXNzU1VGQlNVTXNVMEZCVXl4RFFVRnNRaXhGUVVGeFFrRXNVMEZCVTBvc1RVRkJUVXNzVFVGQmNFTXNSVUZCTkVORUxGVkJRVlZFTEdGQlFYUkVMRVZCUVhGRk8wRkJRMnBGY0VJc2FVSkJRVXQxUWl4SFFVRk1MRU5CUVZOd1FpeGxRVUZVTEVWQlFUQkNXU3hOUVVGTlRTeE5RVUZPTEVOQlFURkNMRVZCUVhsRFRpeE5RVUZOVFN4VFFVRlBMRU5CUVdJc1EwRkJla01zUlVGQk1FUXNRMEZCTVVRN1FVRkRRWEpDTEdsQ1FVRkxkMElzWVVGQlRDeERRVUZ0UW01Q0xHVkJRVzVDTEVWQlFXOURSaXhsUVVGd1F5eEZRVUZ4UkZNc1RVRkJja1E3TzBGQlJVRkxMR3RDUVVGTlNTeE5RVUZPTEVsQlFXZENhRUlzWjBKQlFXZENiMElzUTBGQmFFTTdRVUZEUVZJc2EwSkJRVTFKTEZOQlFVOHNRMEZCWWl4SlFVRnJRbWhDTEdkQ1FVRm5RbkZDTEVOQlFXeERPMEZCUTBGVUxHdENRVUZOU1N4VFFVRlBMRU5CUVdJc1NVRkJhMEpvUWl4blFrRkJaMEp6UWl4RFFVRnNRenRCUVVOSU8wRkJRMG83UVVGbU1rUXNRMEZCYUVVaUxDSm1hV3hsSWpvaWIzVjBiR2x1WlMxaWJXWnZiblF1YW5NaUxDSnpiM1Z5WTJWelEyOXVkR1Z1ZENJNld5SXZLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2x4dUlFTnZjSGx5YVdkb2RDQW9ZeWtnTWpBeE55MHlNREU0SUZocFlXMWxiaUJaWVdwcElGTnZablIzWVhKbElFTnZMaXdnVEhSa0xseHVYRzRnYUhSMGNITTZMeTkzZDNjdVkyOWpiM011WTI5dEwxeHVYRzRnVUdWeWJXbHpjMmx2YmlCcGN5Qm9aWEpsWW5rZ1ozSmhiblJsWkN3Z1puSmxaU0J2WmlCamFHRnlaMlVzSUhSdklHRnVlU0J3WlhKemIyNGdiMkowWVdsdWFXNW5JR0VnWTI5d2VWeHVJRzltSUhSb2FYTWdjMjltZEhkaGNtVWdZVzVrSUdGemMyOWphV0YwWldRZ1pXNW5hVzVsSUhOdmRYSmpaU0JqYjJSbElDaDBhR1VnWENKVGIyWjBkMkZ5WlZ3aUtTd2dZU0JzYVcxcGRHVmtMRnh1SUhkdmNteGtkMmxrWlN3Z2NtOTVZV3gwZVMxbWNtVmxMQ0J1YjI0dFlYTnphV2R1WVdKc1pTd2djbVYyYjJOaFlteGxJR0Z1WkNCdWIyNHRaWGhqYkhWemFYWmxJR3hwWTJWdWMyVmNiaUIwYnlCMWMyVWdRMjlqYjNNZ1EzSmxZWFJ2Y2lCemIyeGxiSGtnZEc4Z1pHVjJaV3h2Y0NCbllXMWxjeUJ2YmlCNWIzVnlJSFJoY21kbGRDQndiR0YwWm05eWJYTXVJRmx2ZFNCemFHRnNiRnh1SUc1dmRDQjFjMlVnUTI5amIzTWdRM0psWVhSdmNpQnpiMlowZDJGeVpTQm1iM0lnWkdWMlpXeHZjR2x1WnlCdmRHaGxjaUJ6YjJaMGQyRnlaU0J2Y2lCMGIyOXNjeUIwYUdGMEozTmNiaUIxYzJWa0lHWnZjaUJrWlhabGJHOXdhVzVuSUdkaGJXVnpMaUJaYjNVZ1lYSmxJRzV2ZENCbmNtRnVkR1ZrSUhSdklIQjFZbXhwYzJnc0lHUnBjM1J5YVdKMWRHVXNYRzRnYzNWaWJHbGpaVzV6WlN3Z1lXNWtMMjl5SUhObGJHd2dZMjl3YVdWeklHOW1JRU52WTI5eklFTnlaV0YwYjNJdVhHNWNiaUJVYUdVZ2MyOW1kSGRoY21VZ2IzSWdkRzl2YkhNZ2FXNGdkR2hwY3lCTWFXTmxibk5sSUVGbmNtVmxiV1Z1ZENCaGNtVWdiR2xqWlc1elpXUXNJRzV2ZENCemIyeGtMbHh1SUZocFlXMWxiaUJaWVdwcElGTnZablIzWVhKbElFTnZMaXdnVEhSa0xpQnlaWE5sY25abGN5QmhiR3dnY21sbmFIUnpJRzV2ZENCbGVIQnlaWE56YkhrZ1ozSmhiblJsWkNCMGJ5QjViM1V1WEc1Y2JpQlVTRVVnVTA5R1ZGZEJVa1VnU1ZNZ1VGSlBWa2xFUlVRZ1hDSkJVeUJKVTF3aUxDQlhTVlJJVDFWVUlGZEJVbEpCVGxSWklFOUdJRUZPV1NCTFNVNUVMQ0JGV0ZCU1JWTlRJRTlTWEc0Z1NVMVFURWxGUkN3Z1NVNURURlZFU1U1SElFSlZWQ0JPVDFRZ1RFbE5TVlJGUkNCVVR5QlVTRVVnVjBGU1VrRk9WRWxGVXlCUFJpQk5SVkpEU0VGT1ZFRkNTVXhKVkZrc1hHNGdSa2xVVGtWVFV5QkdUMUlnUVNCUVFWSlVTVU5WVEVGU0lGQlZVbEJQVTBVZ1FVNUVJRTVQVGtsT1JsSkpUa2RGVFVWT1ZDNGdTVTRnVGs4Z1JWWkZUbFFnVTBoQlRFd2dWRWhGWEc0Z1FWVlVTRTlTVXlCUFVpQkRUMUJaVWtsSFNGUWdTRTlNUkVWU1V5QkNSU0JNU1VGQ1RFVWdSazlTSUVGT1dTQkRURUZKVFN3Z1JFRk5RVWRGVXlCUFVpQlBWRWhGVWx4dUlFeEpRVUpKVEVsVVdTd2dWMGhGVkVoRlVpQkpUaUJCVGlCQlExUkpUMDRnVDBZZ1EwOU9WRkpCUTFRc0lGUlBVbFFnVDFJZ1QxUklSVkpYU1ZORkxDQkJVa2xUU1U1SElFWlNUMDBzWEc0Z1QxVlVJRTlHSUU5U0lFbE9JRU5QVGs1RlExUkpUMDRnVjBsVVNDQlVTRVVnVTA5R1ZGZEJVa1VnVDFJZ1ZFaEZJRlZUUlNCUFVpQlBWRWhGVWlCRVJVRk1TVTVIVXlCSlRseHVJRlJJUlNCVFQwWlVWMEZTUlM1Y2JpQXFLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xS2lvcUtpb3FLaW9xTDF4dVhHNWpiMjV6ZENCQmMzTmxiV0pzWlhJelJDQTlJSEpsY1hWcGNtVW9KeTR1THk0dUx5NHVMeTR1TDJGemMyVnRZbXhsY2kwelpDY3BPMXh1WTI5dWMzUWdWMlZpWjJ4RGIyeHZja0p0Wm05dWRFRnpjMlZ0WW14bGNpQTlJSEpsY1hWcGNtVW9KeTR1THpKa0wyOTFkR3hwYm1VdFltMW1iMjUwSnlrN1hHNWNibU52Ym5OMElIWmxZek1nUFNCall5NTJiV0YwYUM1MlpXTXpPMXh1WEc1amIyNXpkQ0IyWldNelgzUmxiWEJmYkc5allXd2dQU0IyWldNekxtTnlaV0YwWlNncE8xeHVZMjl1YzNRZ2RtVmpNMTkwWlcxd1gzZHZjbXhrSUQwZ2RtVmpNeTVqY21WaGRHVW9LVHRjYmx4dVpYaHdiM0owSUdSbFptRjFiSFFnWTJ4aGMzTWdWMlZpWjJ4RGIyeHZja0p0Wm05dWRFRnpjMlZ0WW14bGNqTkVJR1Y0ZEdWdVpITWdWMlZpWjJ4RGIyeHZja0p0Wm05dWRFRnpjMlZ0WW14bGNpQjdYRzVjYm4xY2JseHVZMk11YW5NdWJXbDRhVzRvVjJWaVoyeERiMnh2Y2tKdFptOXVkRUZ6YzJWdFlteGxjak5FTG5CeWIzUnZkSGx3WlN3Z1FYTnpaVzFpYkdWeU0wUXNJSHRjYmlBZ0lDQjFjR1JoZEdWWGIzSnNaRlpsY25SeklDaGpiMjF3S1NCN1hHNGdJQ0FnSUNBZ0lHeGxkQ0J0WVhSeWFYZ2dQU0JqYjIxd0xtNXZaR1V1WDNkdmNteGtUV0YwY21sNE8xeHVJQ0FnSUNBZ0lDQnNaWFFnYkc5allXd2dQU0IwYUdsekxsOXNiMk5oYkR0Y2JpQWdJQ0FnSUNBZ2JHVjBJSGR2Y214a0lEMGdkR2hwY3k1ZmNtVnVaR1Z5UkdGMFlTNTJSR0YwWVhOYk1GMDdYRzVjYmlBZ0lDQWdJQ0FnYkdWMElHWnNiMkYwYzFCbGNsWmxjblFnUFNCMGFHbHpMbVpzYjJGMGMxQmxjbFpsY25RN1hHNGdJQ0FnSUNBZ0lHWnZjaUFvYkdWMElHOW1abk5sZENBOUlEQTdJRzltWm5ObGRDQThJSGR2Y214a0xteGxibWQwYURzZ2IyWm1jMlYwSUNzOUlHWnNiMkYwYzFCbGNsWmxjblFwSUh0Y2JpQWdJQ0FnSUNBZ0lDQWdJSFpsWXpNdWMyVjBLSFpsWXpOZmRHVnRjRjlzYjJOaGJDd2diRzlqWVd4YmIyWm1jMlYwWFN3Z2JHOWpZV3hiYjJabWMyVjBLekZkTENBd0tUdGNiaUFnSUNBZ0lDQWdJQ0FnSUhabFl6TXVkSEpoYm5ObWIzSnRUV0YwTkNoMlpXTXpYM1JsYlhCZmQyOXliR1FzSUhabFl6TmZkR1Z0Y0Y5c2IyTmhiQ3dnYldGMGNtbDRLVHRjYmx4dUlDQWdJQ0FnSUNBZ0lDQWdkMjl5YkdSYmIyWm1jMlYwWFNBOUlIWmxZek5mZEdWdGNGOTNiM0pzWkM1NE8xeHVJQ0FnSUNBZ0lDQWdJQ0FnZDI5eWJHUmJiMlptYzJWMEt6RmRJRDBnZG1Wak0xOTBaVzF3WDNkdmNteGtMbms3WEc0Z0lDQWdJQ0FnSUNBZ0lDQjNiM0pzWkZ0dlptWnpaWFFyTWwwZ1BTQjJaV016WDNSbGJYQmZkMjl5YkdRdWVqdGNiaUFnSUNBZ0lDQWdmVnh1SUNBZ0lIMWNibjBwTzF4dUlsMTkiXX0=